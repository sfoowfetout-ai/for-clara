<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Clara Runner</title>
  <style>
    :root{
      --txtInv:rgba(255,255,255,.97);
      --mutedInv:rgba(255,255,255,.80);
      --shadow: 0 24px 70px rgba(0,0,0,.40);
      --radius: 18px;
      --stroke: rgba(255,255,255,.22);
      --glass: rgba(0,0,0,.14);
      --glass2: rgba(255,255,255,.12);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--txtInv);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:22px;
      background:
        radial-gradient(1200px 800px at 12% 18%, rgba(125,211,252,.55), transparent 62%),
        radial-gradient(1100px 750px at 88% 20%, rgba(167,139,250,.50), transparent 60%),
        radial-gradient(1000px 700px at 55% 85%, rgba(251,113,133,.40), transparent 60%),
        radial-gradient(900px 600px at 40% 92%, rgba(251,191,36,.35), transparent 60%),
        linear-gradient(180deg, #081028, #0d1a33);
    }
    .wrap{ width:min(1120px, 100%); display:grid; gap:12px; }
    .card{
      border-radius: var(--radius);
      overflow:hidden;
      box-shadow: var(--shadow);
      position:relative;
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
      border:1px solid var(--stroke);
      backdrop-filter: blur(10px);
    }
    .topbar{
      height:10px;
      background: repeating-linear-gradient(90deg,
        rgba(255,47,90,.92) 0 32px,
        rgba(255,209,102,.92) 32px 64px,
        rgba(22,211,200,.92) 64px 96px
      );
    }
    header{
      padding:18px 18px 10px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .title h1{ margin:0 0 6px; font-size: clamp(22px, 2.2vw, 32px); letter-spacing:-.02em; line-height:1.1; }
    .title p{ margin:0; color:var(--mutedInv); font-size:14.5px; line-height:1.5; max-width: 880px; }
    .chips{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end; }
    .chip{
      border:1px solid rgba(255,255,255,.26);
      background: rgba(0,0,0,.16);
      padding:7px 10px;
      border-radius:999px;
      font-size:12.5px;
      color: rgba(255,255,255,.90);
      user-select:none;
      white-space:nowrap;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      border-top:1px solid rgba(255,255,255,.14);
      border-bottom:1px solid rgba(255,255,255,.14);
      background:
        radial-gradient(1100px 520px at 50% 35%, rgba(255,255,255,.10), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,.10));
    }
    .footer{
      padding:12px 18px 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      color: rgba(255,255,255,.90);
      font-size:12.5px;
    }
    .hud{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .stat{
      border:1px solid rgba(255,255,255,.22);
      background: rgba(0,0,0,.14);
      padding:8px 10px;
      border-radius:12px;
      min-width: 108px;
    }
    .stat b{color:rgba(255,255,255,.99)}
    .buttons{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button{
      border:1px solid rgba(255,255,255,.28);
      background: rgba(0,0,0,.14);
      color: rgba(255,255,255,.97);
      padding:9px 12px;
      border-radius:999px;
      cursor:pointer;
      font-weight:800;
      letter-spacing:-.01em;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
    }
    button:hover{ background: rgba(255,255,255,.12); }
    button:active{ transform: scale(.98); }
    .primary{ background: rgba(255,47,90,.20); border-color: rgba(255,47,90,.45); }
    .primary:hover{ background: rgba(255,47,90,.30); border-color: rgba(255,47,90,.60); }
    .hint{ opacity:.92; font-size:12px; color: rgba(255,255,255,.78); max-width: 560px; }
  </style>
</head>

<body>
  <main class="wrap">
    <section class="card">
      <div class="topbar"></div>

      <header>
        <div class="title">
          <h1>Clara Runner</h1>
          <p>
            Flèches gauche/droite : changer de voie. Espace : sauter et démarrer.
            P : pause. R : recommencer. Les fleurs donnent des points et boostent le multiplicateur.
            Soufiane donne une seconde vie (max 2).
          </p>
        </div>
        <div class="chips">
          <span class="chip">Left/Right: lane</span>
          <span class="chip">Space: jump/start</span>
          <span class="chip">P: pause</span>
          <span class="chip">R: restart</span>
        </div>
      </header>

      <canvas id="game" width="1100" height="640"></canvas>

      <div class="footer">
        <div class="hud">
          <div class="stat">Status: <b id="status">Loading</b></div>
          <div class="stat">Score: <b id="score">0</b></div>
          <div class="stat">Best: <b id="best">0</b></div>
          <div class="stat">Flowers: <b id="flowers">0</b></div>
          <div class="stat">Level: <b id="level">1</b></div>
          <div class="stat">Multiplier: <b id="mult">x1.0</b></div>
          <div class="stat">Lives: <b id="lives">1/2</b></div>
          <span class="hint" id="hint"></span>
        </div>

        <div class="buttons">
          <button class="primary" id="btnRestart">Restart</button>
          <button id="btnMusic">Play music</button>
        </div>
      </div>
    </section>
  </main>

  <script>
    // Bump this if images/audio look cached
    const ASSET_VERSION = "v40";

    const ASSETS = {
      clara: `clara.png?${ASSET_VERSION}`,
      fleurs: `fleurs.png?${ASSET_VERSION}`,
      soufiane: `soufiane.png?${ASSET_VERSION}`,
      obstacleCandidates: [
        `badvibes.png?${ASSET_VERSION}`,
        `ahmed.png?${ASSET_VERSION}`,
        `obstacle.png?${ASSET_VERSION}`
      ],
      music: `music.mp3?${ASSET_VERSION}`
    };

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const ui = {
      status: document.getElementById("status"),
      score: document.getElementById("score"),
      best: document.getElementById("best"),
      flowers: document.getElementById("flowers"),
      level: document.getElementById("level"),
      mult: document.getElementById("mult"),
      lives: document.getElementById("lives"),
      hint: document.getElementById("hint"),
      btnRestart: document.getElementById("btnRestart"),
      btnMusic: document.getElementById("btnMusic"),
    };

    const BEST_KEY = "clara_runner_best_v40";
    let best = Number(localStorage.getItem(BEST_KEY) || 0);
    ui.best.textContent = String(best);

    const W = canvas.width, H = canvas.height;

    // Audio (user gesture)
    const audio = new Audio();
    audio.loop = true;
    audio.preload = "auto";
    audio.src = ASSETS.music;
    let musicReady = false;
    audio.addEventListener("canplaythrough", () => musicReady = true);
    audio.addEventListener("error", () => musicReady = false);

    // Image loader
    function loadImage(src){
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve({ ok:true, img, src });
        img.onerror = () => resolve({ ok:false, img:null, src });
        img.src = src;
      });
    }

    const IMG = { clara:null, fleurs:null, soufiane:null, obstacle:null, obstacleSrc:"" };

    async function loadAssets(){
      const rClara = await loadImage(ASSETS.clara);
      const rFleurs = await loadImage(ASSETS.fleurs);
      const rSouf = await loadImage(ASSETS.soufiane);

      let rObs = null;
      for (const s of ASSETS.obstacleCandidates){
        const rr = await loadImage(s);
        if (rr.ok){ rObs = rr; break; }
      }
      if (!rObs) rObs = { ok:false, img:null, src:"(none)" };

      IMG.clara = rClara.ok ? rClara.img : null;
      IMG.fleurs = rFleurs.ok ? rFleurs.img : null;
      IMG.soufiane = rSouf.ok ? rSouf.img : null;
      IMG.obstacle = rObs.ok ? rObs.img : null;
      IMG.obstacleSrc = rObs.ok ? rObs.src : "";

      const problems = [];
      if (!IMG.clara) problems.push("Missing clara.png");
      if (!IMG.fleurs) problems.push("Missing fleurs.png");
      if (!IMG.soufiane) problems.push("Missing soufiane.png");
      if (!IMG.obstacle) problems.push("Missing obstacle image (badvibes/ahmed/obstacle)");

      if (problems.length){
        ui.hint.textContent = problems.join(" | ");
        ui.status.textContent = "Fallback";
      } else {
        ui.hint.textContent = "Obstacle loaded: " + IMG.obstacleSrc.split("?")[0];
        ui.status.textContent = "Press Space to Start";
      }
    }

    // Road perspective
    const road = {
      cx: W/2,
      topY: 100,
      botY: H - 56,
      topW: W * 0.15,
      botW: W * 0.80,
      curbPad: 22, // sidewalk width at bottom (scaled with perspective)
    };
    const lanes = [-1, 0, 1];
    const laneIndex = (lane) => lane === -1 ? 0 : (lane === 0 ? 1 : 2);

    function roadWAt(y){
      const t = (y - road.topY) / (road.botY - road.topY);
      return road.topW + t*(road.botW - road.topW);
    }
    function roadLeftAt(y){
      const w = roadWAt(y);
      return road.cx - w/2;
    }
    function laneX(lane, y){
      const left = roadLeftAt(y);
      const w = roadWAt(y);
      const lw = w/3;
      return left + lw*(laneIndex(lane) + 0.5);
    }

    // Game state
    const game = {
      state: "start",
      lastT: performance.now(),
      t: 0,
      scroll: 0,
      speed: 300,
      spawnTimer: 0,
      spawnEvery: 0.96,

      score: 0,
      flowers: 0,
      level: 1,

      mult: 1.0,
      combo: 0,
      lastFlowerTime: 0,

      lives: 1,       // 1..2
      invuln: 0,      // seconds
      shake: 0,

      // anti-farming for life
      lastLifeGainTime: -999
    };

    // Player
    const player = {
      lane: 0,
      y: H - 178,
      x: laneX(0, H - 178),
      r: 36,

      switching: false,
      fromLane: 0,
      toLane: 0,
      switchT: 0,
      switchDuration: 0.085,

      jumping: false,
      z: 0,
      vz: 0,
      gravity: 3000,
      jumpPower: 1020,
    };

    // Entities
    let obstacles = [];
    let pickups = []; // {type:"flower"|"life", lane, y, r}

    // Controls
    function requestLane(delta){
      if (game.state !== "play") return;
      const idx = lanes.indexOf(player.lane);
      const next = lanes[Math.max(0, Math.min(2, idx + delta))];
      if (next === player.lane) return;

      player.switching = true;
      player.fromLane = player.lane;
      player.toLane = next;
      player.switchT = 0;
      player.lane = next;
    }
    function tryJump(){
      if (game.state !== "play") return;
      if (player.jumping) return;
      player.jumping = true;
      player.vz = player.jumpPower;
    }
    function togglePause(){
      if (game.state === "play"){
        game.state = "pause";
        ui.status.textContent = "Paused";
      } else if (game.state === "pause"){
        game.state = "play";
        ui.status.textContent = "Playing";
      }
    }
    function restart(){
      obstacles = [];
      pickups = [];

      game.state = "start";
      game.scroll = 0;
      game.speed = 300;
      game.spawnTimer = 0;
      game.spawnEvery = 0.96;

      game.score = 0;
      game.flowers = 0;
      game.level = 1;

      game.mult = 1.0;
      game.combo = 0;
      game.lastFlowerTime = 0;

      game.lives = 1;
      game.invuln = 0;
      game.shake = 0;
      game.lastLifeGainTime = -999;

      player.lane = 0;
      player.x = laneX(0, player.y);
      player.switching = false;
      player.jumping = false;
      player.z = 0;
      player.vz = 0;

      ui.status.textContent = "Press Space to Start";
    }

    function onHit(){
      if (game.invuln > 0) return;

      if (game.lives > 1){
        game.lives -= 1;
        game.invuln = 1.15;
        game.shake = 10;

        // remove close obstacles to avoid instant chain hits
        obstacles = obstacles.filter(o => o.y < road.topY + 40 || o.y > player.y + 60);

        // penalty
        game.combo = 0;
        game.mult = 1.0;
        return;
      }

      game.state = "over";
      ui.status.textContent = "Game Over";
      game.shake = 12;

      if (game.score > best){
        best = game.score;
        localStorage.setItem(BEST_KEY, String(best));
        ui.best.textContent = String(best);
      }
    }

    window.addEventListener("keydown", (e) => {
      const k = (e.key || "").toLowerCase();

      if (k === "arrowleft") requestLane(-1);
      if (k === "arrowright") requestLane(+1);

      if (k === " "){
        e.preventDefault();
        if (game.state === "start"){
          game.state = "play";
          ui.status.textContent = "Playing";
          return;
        }
        if (game.state === "play") tryJump();
      }

      if (k === "p"){
        if (game.state === "play" || game.state === "pause") togglePause();
      }

      if (k === "r") restart();
    });

    ui.btnRestart.addEventListener("click", restart);

    ui.btnMusic.addEventListener("click", async () => {
      if (!musicReady){
        ui.status.textContent = "No music.mp3 found";
        return;
      }
      if (audio.paused){
        try { await audio.play(); ui.btnMusic.textContent = "Stop music"; }
        catch { ui.status.textContent = "Click again to enable audio"; }
      } else {
        audio.pause();
        ui.btnMusic.textContent = "Play music";
      }
    });

    // Helpers
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function rand(a,b){ return a + Math.random()*(b-a); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function circleHit(ax, ay, ar, bx, by, br){
      const dx = ax-bx, dy = ay-by;
      return (dx*dx + dy*dy) <= (ar+br)*(ar+br);
    }

    // Drawing helpers
    function drawCircleImage(img, x, y, r){
      const size = r * 2.35;
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.closePath();
      ctx.clip();
      ctx.drawImage(img, x - size/2, y - size/2, size, size);
      ctx.restore();

      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,.25)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    // Environment: no buildings. Clean sidewalks + lamps + banners.
    const env = {
      lamps: [],
      banners: [],
      init(){
        this.lamps = [];
        this.banners = [];

        for (let i=0;i<22;i++){
          this.lamps.push({
            edge: Math.random() < 0.5 ? -1 : 1,
            y: rand(road.topY+40, road.botY-120),
            depth: rand(0.45, 1.0)
          });
        }
        for (let i=0;i<12;i++){
          this.banners.push({
            y: rand(road.topY+70, road.botY-260),
            depth: rand(0.50, 1.0),
            type: Math.random() < 0.6 ? "catalan" : "spain"
          });
        }
      }
    };

    function drawFlagCloth(x, y, w, h, type, alpha){
      ctx.save();
      ctx.globalAlpha = alpha;

      // wave clip
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.quadraticCurveTo(x+w*0.55, y+h*0.20, x+w, y+h*0.08);
      ctx.quadraticCurveTo(x+w*0.55, y+h*0.60, x+w, y+h*0.42);
      ctx.quadraticCurveTo(x+w*0.55, y+h*0.94, x+w, y+h*0.78);
      ctx.lineTo(x+w, y+h);
      ctx.lineTo(x, y+h);
      ctx.closePath();
      ctx.clip();

      if (type === "catalan"){
        const stripes = 6;
        for (let i=0;i<stripes;i++){
          ctx.fillStyle = (i%2===0) ? "rgba(255,209,102,.95)" : "rgba(255,47,90,.95)";
          ctx.fillRect(x, y + i*(h/stripes), w, (h/stripes));
        }
      } else {
        ctx.fillStyle = "rgba(255,47,90,.95)";
        ctx.fillRect(x, y, w, h*0.28);
        ctx.fillStyle = "rgba(255,209,102,.95)";
        ctx.fillRect(x, y+h*0.28, w, h*0.44);
        ctx.fillStyle = "rgba(255,47,90,.95)";
        ctx.fillRect(x, y+h*0.72, w, h*0.28);
      }

      ctx.restore();
      ctx.restore();
    }

    function drawSkyGlow(){
      ctx.save();
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0.00, "rgba(125,211,252,.22)");
      g.addColorStop(0.40, "rgba(167,139,250,.16)");
      g.addColorStop(0.78, "rgba(251,113,133,.10)");
      g.addColorStop(1.00, "rgba(0,0,0,.05)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);
      ctx.restore();
    }

    function drawRoadAndSidewalk(){
      // Road polygon
      const topL = { x: road.cx - road.topW/2, y: road.topY };
      const topR = { x: road.cx + road.topW/2, y: road.topY };
      const botL = { x: road.cx - road.botW/2, y: road.botY };
      const botR = { x: road.cx + road.botW/2, y: road.botY };

      // Sidewalks (curbs) as expanded polygon strips
      ctx.save();

      // sidewalks glow
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "rgba(255,255,255,1)";
      ctx.beginPath();
      ctx.moveTo(topL.x - 10, topL.y);
      ctx.lineTo(topL.x + 2, topL.y);
      ctx.lineTo(botL.x + 2, botL.y);
      ctx.lineTo(botL.x - road.curbPad, botL.y);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(topR.x - 2, topR.y);
      ctx.lineTo(topR.x + 10, topR.y);
      ctx.lineTo(botR.x + road.curbPad, botR.y);
      ctx.lineTo(botR.x - 2, botR.y);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;

      // sidewalks main
      ctx.fillStyle = "rgba(255,255,255,.10)";
      ctx.beginPath();
      ctx.moveTo(topL.x - 12, topL.y);
      ctx.lineTo(topL.x + 2, topL.y);
      ctx.lineTo(botL.x + 2, botL.y);
      ctx.lineTo(botL.x - road.curbPad, botL.y);
      ctx.closePath();
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(topR.x - 2, topR.y);
      ctx.lineTo(topR.x + 12, topR.y);
      ctx.lineTo(botR.x + road.curbPad, botR.y);
      ctx.lineTo(botR.x - 2, botR.y);
      ctx.closePath();
      ctx.fill();

      // Road fill
      ctx.fillStyle = "rgba(0,0,0,.20)";
      ctx.beginPath();
      ctx.moveTo(topL.x, topL.y);
      ctx.lineTo(topR.x, topR.y);
      ctx.lineTo(botR.x, botR.y);
      ctx.lineTo(botL.x, botL.y);
      ctx.closePath();
      ctx.fill();

      // Road edge
      ctx.strokeStyle = "rgba(255,255,255,.22)";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(topL.x, topL.y);
      ctx.lineTo(topR.x, topR.y);
      ctx.lineTo(botR.x, botR.y);
      ctx.lineTo(botL.x, botL.y);
      ctx.closePath();
      ctx.stroke();

      // Lane dashes
      ctx.strokeStyle = "rgba(255,255,255,.28)";
      ctx.lineWidth = 2;

      const dash = 22, gap = 18;
      const offset = (game.t * game.speed * 0.11) % (dash+gap);
      ctx.setLineDash([dash, gap]);
      ctx.lineDashOffset = -offset;

      const step = 16;
      for (let y = road.topY; y <= road.botY; y += step){
        const left = roadLeftAt(y);
        const w = roadWAt(y);
        const lw = w/3;
        const x1 = left + lw;
        const x2 = left + lw*2;
        const persp = (y - road.topY) / (road.botY - road.topY);
        const seg = 10 + persp*26;

        ctx.beginPath(); ctx.moveTo(x1, y); ctx.lineTo(x1, y + seg); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x2, y); ctx.lineTo(x2, y + seg); ctx.stroke();
      }
      ctx.setLineDash([]);

      // Sidewalk texture lines (subtle)
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = "rgba(255,255,255,.20)";
      ctx.lineWidth = 1;
      for (let y = road.topY + 20; y <= road.botY; y += 26){
        const left = roadLeftAt(y);
        const w = roadWAt(y);
        const t = (y - road.topY) / (road.botY - road.topY);
        const curb = 6 + t * (road.curbPad - 6);

        ctx.beginPath();
        ctx.moveTo(left - curb, y);
        ctx.lineTo(left, y);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(left + w, y);
        ctx.lineTo(left + w + curb, y);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;

      ctx.restore();
    }

    function drawLamps(){
      const span = (road.botY - road.topY);

      for (const l of env.lamps){
        let yy = l.y + (game.scroll * 0.30) * (1 - l.depth);
        while (yy > road.botY) yy -= span;

        const persp = (yy - road.topY) / (road.botY - road.topY);
        const scale = 0.55 + persp*0.95;

        const left = roadLeftAt(yy);
        const w = roadWAt(yy);

        const curb = 6 + persp * (road.curbPad - 6);
        const edgeX = l.edge < 0 ? (left - curb) : (left + w + curb);
        const x = edgeX + (l.edge < 0 ? -10*scale : 10*scale);

        ctx.save();
        ctx.globalAlpha = 0.80;
        ctx.strokeStyle = "rgba(255,255,255,.28)";
        ctx.lineWidth = 2;

        // pole
        ctx.beginPath();
        ctx.moveTo(x, yy);
        ctx.lineTo(x, yy - 90*scale);
        ctx.stroke();

        // arm
        ctx.beginPath();
        ctx.moveTo(x, yy - 74*scale);
        ctx.lineTo(x + (l.edge < 0 ? 28*scale : -28*scale), yy - 64*scale);
        ctx.stroke();

        // glow
        const lx = x + (l.edge < 0 ? 32*scale : -32*scale);
        const ly = yy - 62*scale;
        const grd = ctx.createRadialGradient(lx, ly, 3, lx, ly, 34*scale);
        grd.addColorStop(0, "rgba(255,209,102,.30)");
        grd.addColorStop(1, "rgba(255,209,102,0)");
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(lx, ly, 34*scale, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
      }
    }

    function drawBanners(){
      const span = (road.botY - road.topY);

      for (const b of env.banners){
        let yy = b.y + (game.scroll * 0.26) * (1 - b.depth);
        while (yy > road.botY) yy -= span;

        const persp = (yy - road.topY) / (road.botY - road.topY);
        if (persp < 0.20 || persp > 0.62) continue;

        const left = roadLeftAt(yy);
        const w = roadWAt(yy);

        const x = left - w*0.10;
        const ww = w * 1.20;
        const hh = 18 + persp*20;

        ctx.save();
        ctx.globalAlpha = 0.78;

        // rope
        ctx.strokeStyle = "rgba(255,255,255,.26)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x, yy);
        ctx.lineTo(x+ww, yy);
        ctx.stroke();

        // cloth
        drawFlagCloth(x, yy + 4, ww, hh, b.type, 0.62);

        ctx.restore();
      }
    }

    function drawPlayer(){
      const shadowScale = clamp(1 - (player.z / 210), 0.55, 1);

      // shadow
      ctx.save();
      ctx.globalAlpha = 0.26;
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.beginPath();
      ctx.ellipse(player.x, player.y + 28, 38*shadowScale, 13*shadowScale, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // invuln blink
      const blink = (game.invuln > 0) ? (Math.sin(game.t*22) > 0) : true;
      if (!blink) return;

      const y = player.y - player.z;

      if (IMG.clara) drawCircleImage(IMG.clara, player.x, y, player.r);
      else{
        ctx.save();
        ctx.fillStyle = "rgba(255,47,90,.22)";
        ctx.beginPath(); ctx.arc(player.x,y,player.r,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }

    function drawObstacle(o){
      const persp = (o.y - road.topY) / (road.botY - road.topY);
      const r = 14 + persp * 32;
      o.r = r;

      const x = laneX(o.lane, o.y);

      if (persp < 0.25 && game.level >= 7){
        ctx.save();
        ctx.globalAlpha = 0.16 + 0.08*Math.sin(game.t*10);
        ctx.fillStyle = "rgba(255,47,90,1)";
        ctx.beginPath();
        ctx.arc(x, o.y, 22, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      if (IMG.obstacle) drawCircleImage(IMG.obstacle, x, o.y, r);
      else{
        ctx.save();
        ctx.fillStyle = "rgba(22,211,200,.18)";
        ctx.beginPath(); ctx.arc(x,o.y,r,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }

    function drawPickup(p){
      const x = laneX(p.lane, p.y);
      const persp = (p.y - road.topY) / (road.botY - road.topY);
      const r = 10 + persp*16;
      p.r = r; p.x = x;

      // glow
      ctx.save();
      ctx.globalAlpha = 0.20;
      ctx.fillStyle = (p.type === "life") ? "rgba(22,211,200,1)" : "rgba(255,209,102,1)";
      ctx.beginPath();
      ctx.arc(x, p.y, r*1.55, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      if (p.type === "flower"){
        if (IMG.fleurs) drawCircleImage(IMG.fleurs, x, p.y, r);
        else{
          ctx.save(); ctx.fillStyle="rgba(255,209,102,.85)";
          ctx.beginPath(); ctx.arc(x,p.y,r,0,Math.PI*2); ctx.fill(); ctx.restore();
        }
      } else {
        if (IMG.soufiane) drawCircleImage(IMG.soufiane, x, p.y, r);
        else{
          ctx.save(); ctx.fillStyle="rgba(22,211,200,.85)";
          ctx.beginPath(); ctx.arc(x,p.y,r,0,Math.PI*2); ctx.fill(); ctx.restore();
        }
      }
    }

    function drawOverlay(){
      if (game.state === "start"){
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.12)";
        ctx.fillRect(0, 0, W, H);

        ctx.fillStyle = "rgba(255,255,255,.98)";
        ctx.font = "900 44px system-ui";
        ctx.textAlign = "center";
        ctx.fillText("Press Space to Start", W/2, H*0.44);

        ctx.fillStyle = "rgba(255,255,255,.86)";
        ctx.font = "16px system-ui";
        ctx.fillText("Left/Right: lane. Space: jump. P: pause. R: restart.", W/2, H*0.44 + 34);
        ctx.restore();
      }
      if (game.state === "pause"){
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.18)";
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = "rgba(255,255,255,.98)";
        ctx.font = "900 46px system-ui";
        ctx.textAlign = "center";
        ctx.fillText("Paused", W/2, H*0.46);
        ctx.fillStyle = "rgba(255,255,255,.86)";
        ctx.font = "16px system-ui";
        ctx.fillText("Press P to resume", W/2, H*0.46 + 32);
        ctx.restore();
      }
      if (game.state === "over"){
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.22)";
        ctx.fillRect(0, H/2 - 84, W, 168);
        ctx.fillStyle = "rgba(255,255,255,.98)";
        ctx.font = "900 52px system-ui";
        ctx.textAlign="center";
        ctx.fillText("Game Over", W/2, H/2 - 14);
        ctx.fillStyle = "rgba(255,255,255,.86)";
        ctx.font = "16px system-ui";
        ctx.fillText("Press R to restart", W/2, H/2 + 28);
        ctx.restore();
      }
    }

    // Difficulty + scoring
    function updateDifficulty(){
      const lvl = 1 + Math.floor(game.score / 340);
      game.level = clamp(lvl, 1, 70);

      const k = clamp((game.level - 1) / 28, 0, 1);
      game.speed = 300 + k * 630;          // 300 -> 930
      game.spawnEvery = 0.98 - k * 0.55;   // 0.98 -> 0.43

      const targetMult = 1 + clamp(game.combo / 14, 0, 3.2);
      game.mult = lerp(game.mult, targetMult, 0.07);
    }

    function spawnPattern(){
      const lvl = game.level;

      const l1 = lanes[Math.floor(Math.random()*3)];
      let l2 = l1; while (l2 === l1) l2 = lanes[Math.floor(Math.random()*3)];

      obstacles.push({ lane:l1, y: road.topY - 60, r:16 });

      // doubles
      const pDouble = clamp(0.08 + (lvl-5)*0.035, 0, 0.68);
      if (lvl >= 6 && Math.random() < pDouble){
        obstacles.push({ lane:l2, y: road.topY - 110, r:16 });
      }

      // sometimes block 2 lanes
      const pTwoBlocked = clamp(0 + (lvl-12)*0.02, 0, 0.32);
      if (lvl >= 14 && Math.random() < pTwoBlocked){
        const safe = lanes[Math.floor(Math.random()*3)];
        for (const ln of lanes){
          if (ln !== safe) obstacles.push({ lane:ln, y: road.topY - 170, r:16 });
        }
      }

      // Flower pickups (main scoring)
      const flowerChance = 0.90;
      if (Math.random() < flowerChance){
        const lane = Math.random() < 0.55 ? l2 : l1;
        const count = (lvl < 12) ? 2 : (lvl < 26 ? 3 : 4);
        for (let i=0;i<count;i++){
          pickups.push({ type:"flower", lane, y: road.topY - 140 - i*52, r:12, x:0 });
        }
      }

      // Life pickup (Soufiane) rules
      // - max 2 lives
      // - cooldown prevents farming
      const lifeCooldownOk = (game.t - game.lastLifeGainTime) > 7.0;
      const baseLifeChance = 0.13; // rare
      if (lvl >= 7 && lifeCooldownOk && Math.random() < baseLifeChance){
        const lane = lanes[Math.floor(Math.random()*3)];
        pickups.push({ type:"life", lane, y: road.topY - 215, r:12, x:0 });
      }
    }

    function updatePlayer(dt){
      if (player.switching){
        player.switchT += dt;
        const a = Math.min(1, player.switchT / player.switchDuration);
        const fromX = laneX(player.fromLane, player.y);
        const toX = laneX(player.toLane, player.y);
        const eased = 1 - Math.pow(1-a, 3);
        player.x = fromX + (toX - fromX) * eased;
        if (a >= 1) player.switching = false;
      } else {
        player.x = laneX(player.lane, player.y);
      }

      if (player.jumping){
        player.z += player.vz * dt;
        player.vz -= player.gravity * dt;
        if (player.z <= 0){
          player.z = 0;
          player.vz = 0;
          player.jumping = false;
        }
      }

      if (game.invuln > 0) game.invuln = Math.max(0, game.invuln - dt);
      if (game.shake > 0) game.shake = Math.max(0, game.shake - 40*dt);
    }

    function updateWorld(dt){
      if (game.state !== "play") return;

      // Base score over time
      game.score += Math.floor(dt * 18 * game.mult);

      updateDifficulty();
      game.scroll += game.speed * dt;

      game.spawnTimer += dt;
      if (game.spawnTimer >= game.spawnEvery){
        game.spawnTimer = 0;
        spawnPattern();
      }

      // Obstacles
      for (let i=obstacles.length-1;i>=0;i--){
        const o = obstacles[i];
        o.y += game.speed * dt;

        const canHit = (player.z < 74) && (game.invuln <= 0);
        const ox = laneX(o.lane, o.y);
        const py = player.y - player.z;

        if (canHit && circleHit(player.x, py, player.r*0.86, ox, o.y, (o.r || 18)*0.86)){
          onHit();
          obstacles.splice(i,1);
          continue;
        }

        if (o.y > H + 160) obstacles.splice(i,1);
      }

      // Pickups
      for (let i=pickups.length-1;i>=0;i--){
        const p = pickups[i];
        p.y += game.speed * dt;

        const px = player.x;
        const py = player.y - player.z;
        const cx = laneX(p.lane, p.y);
        const pr = player.r*0.78;

        if (circleHit(px, py, pr, cx, p.y, (p.r || 14)*1.05)){
          if (p.type === "flower"){
            game.flowers += 1;
            game.combo += 1.0;
            game.lastFlowerTime = game.t;

            // Flower scoring: strong reward
            // includes small scaling by level
            const bonus = Math.floor((150 + game.level*2) * game.mult);
            game.score += bonus;

          } else {
            // Life pickup rules:
            // - if lives < 2: set to 2
            // - if already 2: convert to points
            if (game.lives < 2){
              game.lives = 2;
              game.invuln = Math.max(game.invuln, 0.35);
              game.lastLifeGainTime = game.t;
            } else {
              game.score += 300;
              game.lastLifeGainTime = game.t; // still enforces cooldown
            }
          }

          pickups.splice(i,1);
          continue;
        }

        if (p.y > H + 160) pickups.splice(i,1);
      }

      // Combo decay if no flowers collected recently
      if (game.t - game.lastFlowerTime > 1.4){
        game.combo = Math.max(0, game.combo - dt*1.3);
      }
    }

    function render(){
      // camera shake
      let sx = 0, sy = 0;
      if (game.shake > 0){
        sx = rand(-game.shake, game.shake);
        sy = rand(-game.shake, game.shake);
      }

      ctx.save();
      ctx.translate(sx, sy);
      ctx.clearRect(-60, -60, W+120, H+120);

      drawSkyGlow();
      drawBanners();
      drawRoadAndSidewalk();
      drawLamps();

      // draw pickups then obstacles
      for (const p of pickups) drawPickup(p);
      for (const o of obstacles) drawObstacle(o);

      drawPlayer();
      drawOverlay();

      ctx.restore();
    }

    function loop(now){
      const dt = Math.min(0.033, (now - game.lastT)/1000);
      game.lastT = now;
      game.t += dt;

      if (game.state !== "pause"){
        updatePlayer(dt);
        updateWorld(dt);
      }
      render();

      // UI sync
      ui.score.textContent = String(game.score);
      ui.best.textContent = String(best);
      ui.flowers.textContent = String(game.flowers);
      ui.level.textContent = String(game.level);
      ui.mult.textContent = "x" + game.mult.toFixed(1);
      ui.lives.textContent = `${game.lives}/2`;

      requestAnimationFrame(loop);
    }

    // Init
    env.init();
    restart();

    loadAssets().then(() => {
      requestAnimationFrame(loop);
    });
  </script>
</body>
</html>
