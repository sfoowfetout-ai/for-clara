<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Clara Runner</title>
  <style>
    :root{
      --txtInv:rgba(255,255,255,.96);
      --mutedInv:rgba(255,255,255,.80);
      --shadow: 0 24px 70px rgba(0,0,0,.40);
      --radius: 18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--txtInv);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:22px;
      background:
        radial-gradient(1200px 800px at 12% 18%, rgba(125,211,252,.55), transparent 62%),
        radial-gradient(1100px 750px at 88% 20%, rgba(167,139,250,.50), transparent 60%),
        radial-gradient(1000px 700px at 55% 85%, rgba(251,113,133,.40), transparent 60%),
        radial-gradient(900px 600px at 40% 92%, rgba(251,191,36,.35), transparent 60%),
        linear-gradient(180deg, #081028, #0d1a33);
    }
    .wrap{ width:min(1120px, 100%); display:grid; gap:12px; }
    .card{
      border-radius: var(--radius);
      overflow:hidden;
      box-shadow: var(--shadow);
      position:relative;
      background: linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.22);
      backdrop-filter: blur(10px);
    }
    .topbar{
      height:10px;
      background:
        repeating-linear-gradient(90deg,
          rgba(255,47,90,.92) 0 32px,
          rgba(255,209,102,.92) 32px 64px,
          rgba(22,211,200,.92) 64px 96px
        );
    }
    header{
      padding:18px 18px 10px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }
    .title h1{ margin:0 0 6px; font-size: clamp(22px, 2.2vw, 32px); letter-spacing:-.02em; line-height:1.1; }
    .title p{ margin:0; color:var(--mutedInv); font-size:14.5px; line-height:1.5; max-width: 840px; }
    .chips{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-end; }
    .chip{
      border:1px solid rgba(255,255,255,.26);
      background: rgba(0,0,0,.16);
      padding:7px 10px;
      border-radius:999px;
      font-size:12.5px;
      color: rgba(255,255,255,.86);
      user-select:none;
      white-space:nowrap;
    }
    canvas{
      width:100%;
      height:auto;
      display:block;
      border-top:1px solid rgba(255,255,255,.14);
      border-bottom:1px solid rgba(255,255,255,.14);
      background:
        radial-gradient(1100px 520px at 50% 35%, rgba(255,255,255,.10), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,.10));
    }
    .footer{
      padding:12px 18px 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      color: rgba(255,255,255,.86);
      font-size:12.5px;
    }
    .hud{ display:flex; align-items:center; gap:10px; flex-wrap:wrap; }
    .stat{
      border:1px solid rgba(255,255,255,.22);
      background: rgba(0,0,0,.14);
      padding:8px 10px;
      border-radius:12px;
    }
    .stat b{color:rgba(255,255,255,.98)}
    .buttons{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button{
      border:1px solid rgba(255,255,255,.28);
      background: rgba(0,0,0,.14);
      color: rgba(255,255,255,.96);
      padding:9px 12px;
      border-radius:999px;
      cursor:pointer;
      font-weight:800;
      letter-spacing:-.01em;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
    }
    button:hover{ background: rgba(255,255,255,.12); }
    button:active{ transform: scale(.98); }
    .primary{ background: rgba(255,47,90,.20); border-color: rgba(255,47,90,.45); }
    .primary:hover{ background: rgba(255,47,90,.30); border-color: rgba(255,47,90,.60); }
    .hint{ opacity:.92; font-size:12px; color: rgba(255,255,255,.78); max-width: 560px; }
  </style>
</head>

<body>
  <main class="wrap">
    <section class="card">
      <div class="topbar"></div>
      <header>
        <div class="title">
          <h1>Clara Runner</h1>
          <p>
            Flèches gauche/droite : changer de voie. Espace : sauter et démarrer.
            P : pause. R : recommencer. Ramasse les fleurs pour marquer des points. Soufiane donne une seconde vie (max 2).
          </p>
        </div>
        <div class="chips">
          <span class="chip">Left/Right: lane</span>
          <span class="chip">Space: jump/start</span>
          <span class="chip">P: pause</span>
          <span class="chip">R: restart</span>
        </div>
      </header>

      <canvas id="game" width="1100" height="620"></canvas>

      <div class="footer">
        <div class="hud">
          <div class="stat">Status: <b id="status">Loading</b></div>
          <div class="stat">Score: <b id="score">0</b></div>
          <div class="stat">Best: <b id="best">0</b></div>
          <div class="stat">Level: <b id="level">1</b></div>
          <div class="stat">Multiplier: <b id="mult">x1.0</b></div>
          <div class="stat">Lives: <b id="lives">1/2</b></div>
          <span class="hint" id="hint"></span>
        </div>

        <div class="buttons">
          <button class="primary" id="btnRestart">Restart</button>
          <button id="btnMusic">Play music</button>
        </div>
      </div>
    </section>
  </main>

  <script>
    // If assets look cached, bump this value.
    const ASSET_VERSION = "v31";

    const ASSETS = {
      clara: `clara.png?${ASSET_VERSION}`,
      fleurs: `fleurs.png?${ASSET_VERSION}`,
      soufiane: `soufiane.png?${ASSET_VERSION}`,
      obstacleCandidates: [
        `badvibes.png?${ASSET_VERSION}`,
        `ahmed.png?${ASSET_VERSION}`,
        `obstacle.png?${ASSET_VERSION}`
      ],
      music: `music.mp3?${ASSET_VERSION}`
    };

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const ui = {
      status: document.getElementById("status"),
      score: document.getElementById("score"),
      best: document.getElementById("best"),
      level: document.getElementById("level"),
      mult: document.getElementById("mult"),
      lives: document.getElementById("lives"),
      hint: document.getElementById("hint"),
      btnRestart: document.getElementById("btnRestart"),
      btnMusic: document.getElementById("btnMusic"),
    };

    const BEST_KEY = "clara_runner_best_v31";
    let best = Number(localStorage.getItem(BEST_KEY) || 0);
    ui.best.textContent = String(best);

    const W = canvas.width, H = canvas.height;

    // Audio
    const audio = new Audio();
    audio.loop = true;
    audio.preload = "auto";
    audio.src = ASSETS.music;
    let musicReady = false;
    audio.addEventListener("canplaythrough", () => musicReady = true);
    audio.addEventListener("error", () => musicReady = false);

    // Images
    function loadImage(src){
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => resolve({ ok:true, img, src });
        img.onerror = () => resolve({ ok:false, img:null, src });
        img.src = src;
      });
    }

    const IMG = {
      clara: null,
      obstacle: null,
      fleurs: null,
      soufiane: null,
      obstacleSrc: ""
    };

    async function loadAssets(){
      const results = [];

      const rClara = await loadImage(ASSETS.clara);
      results.push(rClara);

      const rFleurs = await loadImage(ASSETS.fleurs);
      results.push(rFleurs);

      const rSouf = await loadImage(ASSETS.soufiane);
      results.push(rSouf);

      let rObs = null;
      for (const s of ASSETS.obstacleCandidates){
        const rr = await loadImage(s);
        if (rr.ok){ rObs = rr; break; }
      }
      if (!rObs) rObs = { ok:false, img:null, src:"(none)" };
      results.push(rObs);

      IMG.clara = rClara.ok ? rClara.img : null;
      IMG.fleurs = rFleurs.ok ? rFleurs.img : null;
      IMG.soufiane = rSouf.ok ? rSouf.img : null;
      IMG.obstacle = rObs.ok ? rObs.img : null;
      IMG.obstacleSrc = rObs.ok ? rObs.src : "";

      const problems = [];
      if (!IMG.clara) problems.push("Missing clara.png");
      if (!IMG.fleurs) problems.push("Missing fleurs.png");
      if (!IMG.soufiane) problems.push("Missing soufiane.png");
      if (!IMG.obstacle) problems.push("Missing obstacle image (badvibes/ahmed/obstacle)");

      if (problems.length){
        ui.hint.textContent = problems.join(" | ");
        ui.status.textContent = "Fallback";
      } else {
        ui.hint.textContent = "Obstacle loaded: " + IMG.obstacleSrc.split("?")[0];
        ui.status.textContent = "Press Space to Start";
      }
    }

    // Perspective road
    const road = {
      cx: W/2,
      topY: 95,
      botY: H - 50,
      topW: W * 0.15,
      botW: W * 0.80,
    };
    const lanes = [-1, 0, 1];
    const laneIndex = (lane) => lane === -1 ? 0 : (lane === 0 ? 1 : 2);

    function roadWAt(y){
      const t = (y - road.topY) / (road.botY - road.topY);
      return road.topW + t*(road.botW - road.topW);
    }
    function roadLeftAt(y){
      const w = roadWAt(y);
      return road.cx - w/2;
    }
    function laneX(lane, y){
      const left = roadLeftAt(y);
      const w = roadWAt(y);
      const lw = w/3;
      return left + lw*(laneIndex(lane) + 0.5);
    }

    // Game state
    const game = {
      state: "start",
      lastT: performance.now(),
      t: 0,
      scroll: 0,
      speed: 300,
      spawnTimer: 0,
      spawnEvery: 0.92,

      score: 0,
      level: 1,

      mult: 1.0,
      combo: 0,
      lastFlowerTime: 0,

      lives: 1,           // 1..2
      invuln: 0,          // seconds
      shake: 0
    };

    // Player
    const player = {
      lane: 0,
      y: H - 165,
      x: laneX(0, H - 165),
      r: 36,

      switching: false,
      fromLane: 0,
      toLane: 0,
      switchT: 0,
      switchDuration: 0.085,

      jumping: false,
      z: 0,
      vz: 0,
      gravity: 3000,
      jumpPower: 1020,
    };

    // Entities
    let obstacles = [];
    let pickups = []; // {type:"flower"|"life", lane, y, r}

    // Controls
    function requestLane(delta){
      if (game.state !== "play") return;
      const idx = lanes.indexOf(player.lane);
      const next = lanes[Math.max(0, Math.min(2, idx + delta))];
      if (next === player.lane) return;

      player.switching = true;
      player.fromLane = player.lane;
      player.toLane = next;
      player.switchT = 0;
      player.lane = next;
    }
    function tryJump(){
      if (game.state !== "play") return;
      if (player.jumping) return;
      player.jumping = true;
      player.vz = player.jumpPower;
    }
    function togglePause(){
      if (game.state === "play"){
        game.state = "pause";
        ui.status.textContent = "Paused";
      } else if (game.state === "pause"){
        game.state = "play";
        ui.status.textContent = "Playing";
      }
    }
    function restart(){
      obstacles = [];
      pickups = [];

      game.state = "start";
      game.scroll = 0;
      game.speed = 300;
      game.spawnTimer = 0;
      game.spawnEvery = 0.92;

      game.score = 0;
      game.level = 1;

      game.mult = 1.0;
      game.combo = 0;
      game.lastFlowerTime = 0;

      game.lives = 1;
      game.invuln = 0;
      game.shake = 0;

      player.lane = 0;
      player.x = laneX(0, player.y);
      player.switching = false;
      player.jumping = false;
      player.z = 0;
      player.vz = 0;

      ui.status.textContent = "Press Space to Start";
    }

    function onHit(){
      if (game.invuln > 0) return;

      if (game.lives > 1){
        game.lives -= 1;
        game.invuln = 1.10;  // brief invulnerability
        game.shake = 10;

        // remove some nearby obstacles to avoid instant double-hit
        obstacles = obstacles.filter(o => o.y < road.topY + 30 || o.y > player.y + 40);

        // reset combo as penalty
        game.combo = 0;
        game.mult = 1.0;
        return;
      }

      // last life -> game over
      game.state = "over";
      ui.status.textContent = "Game Over";
      game.shake = 12;

      if (game.score > best){
        best = game.score;
        localStorage.setItem(BEST_KEY, String(best));
        ui.best.textContent = String(best);
      }
    }

    window.addEventListener("keydown", (e) => {
      const k = (e.key || "").toLowerCase();

      if (k === "arrowleft") requestLane(-1);
      if (k === "arrowright") requestLane(+1);

      if (k === " "){
        e.preventDefault();
        if (game.state === "start"){
          game.state = "play";
          ui.status.textContent = "Playing";
          return;
        }
        if (game.state === "play") tryJump();
      }

      if (k === "p"){
        if (game.state === "play" || game.state === "pause") togglePause();
      }

      if (k === "r") restart();
    });

    ui.btnRestart.addEventListener("click", restart);

    ui.btnMusic.addEventListener("click", async () => {
      if (!musicReady){
        ui.status.textContent = "No music.mp3 found";
        return;
      }
      if (audio.paused){
        try { await audio.play(); ui.btnMusic.textContent = "Stop music"; }
        catch { ui.status.textContent = "Click again to enable audio"; }
      } else {
        audio.pause();
        ui.btnMusic.textContent = "Play music";
      }
    });

    // Helpers
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function rand(a,b){ return a + Math.random()*(b-a); }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function circleHit(ax, ay, ar, bx, by, br){
      const dx = ax-bx, dy = ay-by;
      return (dx*dx + dy*dy) <= (ar+br)*(ar+br);
    }

    // Crisp environment (no blurry stacking)
    // We draw 2 skyline layers as clean silhouettes + a few facade blocks, no heavy alpha overlaps.
    const env = {
      skylineA: [],
      skylineB: [],
      flags: [],
      init(){
        this.skylineA = [];
        this.skylineB = [];
        this.flags = [];

        for (let i=0;i<18;i++){
          this.skylineA.push({
            side: Math.random()<0.5 ? "L":"R",
            base: rand(road.topY+30, road.botY-160),
            w: rand(70, 140),
            h: rand(140, 280),
            depth: rand(0.35, 0.65)
          });
        }
        for (let i=0;i<14;i++){
          this.skylineB.push({
            side: Math.random()<0.5 ? "L":"R",
            base: rand(road.topY+40, road.botY-160),
            w: rand(60, 120),
            h: rand(110, 230),
            depth: rand(0.70, 1.00)
          });
        }

        for (let i=0;i<16;i++){
          this.flags.push({
            side: Math.random()<0.5 ? "L":"R",
            base: rand(road.topY+50, road.botY-160),
            depth: rand(0.55, 1.0),
            type: Math.random()<0.6 ? "catalan" : "spain"
          });
        }
      }
    };

    function drawFlag(x, y, w, h, type, alpha){
      ctx.save();
      ctx.globalAlpha = alpha;

      // pole
      ctx.strokeStyle = "rgba(255,255,255,.75)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x, y+h);
      ctx.stroke();

      const xx = x + 2, yy = y + 2, ww = w, hh = h;

      // clip wave
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(xx, yy);
      ctx.quadraticCurveTo(xx+ww*0.55, yy+hh*0.15, xx+ww, yy+hh*0.05);
      ctx.quadraticCurveTo(xx+ww*0.55, yy+hh*0.55, xx+ww, yy+hh*0.40);
      ctx.quadraticCurveTo(xx+ww*0.55, yy+hh*0.92, xx+ww, yy+hh*0.75);
      ctx.lineTo(xx+ww, yy+hh);
      ctx.lineTo(xx, yy+hh);
      ctx.closePath();
      ctx.clip();

      if (type === "catalan"){
        const stripes = 6;
        for (let i=0;i<stripes;i++){
          ctx.fillStyle = (i%2===0) ? "rgba(255,209,102,.98)" : "rgba(255,47,90,.98)";
          ctx.fillRect(xx, yy + i*(hh/stripes), ww, (hh/stripes));
        }
      } else {
        ctx.fillStyle = "rgba(255,47,90,.98)";
        ctx.fillRect(xx, yy, ww, hh*0.28);
        ctx.fillStyle = "rgba(255,209,102,.98)";
        ctx.fillRect(xx, yy+hh*0.28, ww, hh*0.44);
        ctx.fillStyle = "rgba(255,47,90,.98)";
        ctx.fillRect(xx, yy+hh*0.72, ww, hh*0.28);
      }

      ctx.restore();
      ctx.restore();
    }

    function drawSkyGlow(){
      ctx.save();
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0.00, "rgba(125,211,252,.22)");
      g.addColorStop(0.40, "rgba(167,139,250,.16)");
      g.addColorStop(0.78, "rgba(251,113,133,.10)");
      g.addColorStop(1.00, "rgba(0,0,0,.05)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);
      ctx.restore();
    }

    function drawSkyline(list, scroll, fillA, fillB){
      const span = (road.botY - road.topY);

      for (const b of list){
        let yy = b.base + (scroll * 0.18) * (1 - b.depth);
        while (yy > road.botY) yy -= span;

        const persp = (yy - road.topY) / (road.botY - road.topY);
        const scale = 0.55 + persp*0.95;

        const left = roadLeftAt(yy);
        const w = roadWAt(yy);

        const bw = b.w * scale;
        const bh = b.h * scale;

        const offset = 22 + (1 - b.depth)*32;
        const x = b.side === "L" ? (left - offset - bw) : (left + w + offset);

        // crisp silhouette
        ctx.save();
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = fillA;
        ctx.fillRect(x, yy - bh, bw, bh);

        // facade detail (small bright blocks) to avoid blur
        ctx.fillStyle = fillB;
        const win = 9*scale, gap = 7*scale;
        for (let r=0;r<6;r++){
          for (let c=0;c<4;c++){
            const px = x + 10*scale + c*(win+gap);
            const py = (yy - bh) + 14*scale + r*(win+gap);
            if (px + win < x + bw - 10*scale && py + win < yy - 10*scale){
              if (((r+c) % 3) === 0) ctx.fillRect(px, py, win, win);
            }
          }
        }

        ctx.restore();
      }
    }

    function drawFlags(scroll){
      const span = (road.botY - road.topY);

      for (const f of env.flags){
        let yy = f.base + (scroll * 0.20) * (1 - f.depth);
        while (yy > road.botY) yy -= span;

        const persp = (yy - road.topY) / (road.botY - road.topY);
        if (persp < 0.20 || persp > 0.75) continue;

        const scale = 0.55 + persp*0.95;

        const left = roadLeftAt(yy);
        const w = roadWAt(yy);
        const edgeX = f.side === "L" ? (left - 18*scale) : (left + w + 18*scale);
        drawFlag(edgeX, yy - 70*scale, 26*scale, 34*scale, f.type, 0.95);
      }
    }

    function drawRoad(){
      // road
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.20)";
      ctx.beginPath();
      ctx.moveTo(road.cx - road.topW/2, road.topY);
      ctx.lineTo(road.cx + road.topW/2, road.topY);
      ctx.lineTo(road.cx + road.botW/2, road.botY);
      ctx.lineTo(road.cx - road.botW/2, road.botY);
      ctx.closePath();
      ctx.fill();

      // edge
      ctx.strokeStyle = "rgba(255,255,255,.20)";
      ctx.lineWidth = 3;
      ctx.stroke();

      // lane dashes
      ctx.strokeStyle = "rgba(255,255,255,.26)";
      ctx.lineWidth = 2;

      const dash = 22, gap = 18;
      const offset = (game.t * game.speed * 0.11) % (dash+gap);
      ctx.setLineDash([dash, gap]);
      ctx.lineDashOffset = -offset;

      const step = 16;
      for (let y = road.topY; y <= road.botY; y += step){
        const left = roadLeftAt(y);
        const w = roadWAt(y);
        const lw = w/3;
        const x1 = left + lw;
        const x2 = left + lw*2;

        const persp = (y - road.topY) / (road.botY - road.topY);
        const seg = 10 + persp*26;

        ctx.beginPath(); ctx.moveTo(x1, y); ctx.lineTo(x1, y + seg); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x2, y); ctx.lineTo(x2, y + seg); ctx.stroke();
      }
      ctx.setLineDash([]);
      ctx.restore();
    }

    function drawCircleImage(img, x, y, r){
      const size = r * 2.35;
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.closePath();
      ctx.clip();
      ctx.drawImage(img, x - size/2, y - size/2, size, size);
      ctx.restore();

      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,.24)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    function drawPlayer(){
      const shadowScale = clamp(1 - (player.z / 210), 0.55, 1);

      // shadow
      ctx.save();
      ctx.globalAlpha = 0.26;
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.beginPath();
      ctx.ellipse(player.x, player.y + 28, 38*shadowScale, 13*shadowScale, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      const y = player.y - player.z;

      // invulnerability blink
      const blink = (game.invuln > 0) ? (Math.sin(game.t*22) > 0) : true;
      if (!blink) return;

      if (IMG.clara){
        drawCircleImage(IMG.clara, player.x, y, player.r);
      } else {
        ctx.save();
        ctx.fillStyle = "rgba(255,47,90,.20)";
        ctx.beginPath(); ctx.arc(player.x,y,player.r,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }

    function drawObstacle(o){
      const persp = (o.y - road.topY) / (road.botY - road.topY);
      const r = 14 + persp * 32;
      o.r = r;

      const x = laneX(o.lane, o.y);

      // warning pulse
      if (persp < 0.25 && game.level >= 7){
        ctx.save();
        ctx.globalAlpha = 0.16 + 0.08*Math.sin(game.t*10);
        ctx.fillStyle = "rgba(255,47,90,1)";
        ctx.beginPath();
        ctx.arc(x, o.y, 22, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      if (IMG.obstacle){
        drawCircleImage(IMG.obstacle, x, o.y, r);
      } else {
        ctx.save();
        ctx.fillStyle = "rgba(22,211,200,.18)";
        ctx.beginPath(); ctx.arc(x,o.y,r,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }

    function drawPickup(p){
      const x = laneX(p.lane, p.y);
      const persp = (p.y - road.topY) / (road.botY - road.topY);
      const r = 10 + persp*16;
      p.r = r;
      p.x = x;

      // Slight glow
      ctx.save();
      ctx.globalAlpha = 0.20;
      ctx.fillStyle = (p.type === "life") ? "rgba(33,192,209,1)" : "rgba(255,209,102,1)";
      ctx.beginPath();
      ctx.arc(x, p.y, r*1.55, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      if (p.type === "flower"){
        if (IMG.fleurs) drawCircleImage(IMG.fleurs, x, p.y, r);
        else {
          ctx.save(); ctx.fillStyle="rgba(255,209,102,.85)";
          ctx.beginPath(); ctx.arc(x,p.y,r,0,Math.PI*2); ctx.fill(); ctx.restore();
        }
      } else {
        if (IMG.soufiane) drawCircleImage(IMG.soufiane, x, p.y, r);
        else {
          ctx.save(); ctx.fillStyle="rgba(33,192,209,.85)";
          ctx.beginPath(); ctx.arc(x,p.y,r,0,Math.PI*2); ctx.fill(); ctx.restore();
        }
      }
    }

    function drawOverlay(){
      if (game.state === "start"){
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.14)";
        ctx.fillRect(0, 0, W, H);

        ctx.fillStyle = "rgba(255,255,255,.98)";
        ctx.font = "900 44px system-ui";
        ctx.textAlign = "center";
        ctx.fillText("Press Space to Start", W/2, H*0.44);

        ctx.fillStyle = "rgba(255,255,255,.84)";
        ctx.font = "16px system-ui";
        ctx.fillText("Left/Right: lane. Space: jump. P: pause.", W/2, H*0.44 + 34);
        ctx.restore();
      }

      if (game.state === "pause"){
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.20)";
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = "rgba(255,255,255,.98)";
        ctx.font = "900 46px system-ui";
        ctx.textAlign = "center";
        ctx.fillText("Paused", W/2, H*0.46);
        ctx.fillStyle = "rgba(255,255,255,.84)";
        ctx.font = "16px system-ui";
        ctx.fillText("Press P to resume", W/2, H*0.46 + 32);
        ctx.restore();
      }

      if (game.state === "over"){
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.26)";
        ctx.fillRect(0, H/2 - 84, W, 168);
        ctx.fillStyle = "rgba(255,255,255,.98)";
        ctx.font = "900 52px system-ui";
        ctx.textAlign="center";
        ctx.fillText("Game Over", W/2, H/2 - 14);
        ctx.fillStyle = "rgba(255,255,255,.86)";
        ctx.font = "16px system-ui";
        ctx.fillText("Press R to restart", W/2, H/2 + 28);
        ctx.restore();
      }
    }

    // Difficulty & spawning
    function updateDifficulty(){
      const lvl = 1 + Math.floor(game.score / 320);
      game.level = clamp(lvl, 1, 60);

      const k = clamp((game.level - 1) / 26, 0, 1);
      game.speed = 300 + k * 620;          // 300 -> 920
      game.spawnEvery = 0.95 - k * 0.52;   // 0.95 -> 0.43

      // multiplier follows combo
      const targetMult = 1 + clamp(game.combo / 16, 0, 3.0);
      game.mult = lerp(game.mult, targetMult, 0.07);
    }

    function spawnPattern(){
      // Obstacles
      const lvl = game.level;

      const l1 = lanes[Math.floor(Math.random()*3)];
      let l2 = l1; while (l2 === l1) l2 = lanes[Math.floor(Math.random()*3)];

      obstacles.push({ lane:l1, y: road.topY - 60, r:16 });

      // More doubles with level
      const pDouble = clamp(0.08 + (lvl-4)*0.035, 0, 0.65);
      if (lvl >= 5 && Math.random() < pDouble){
        obstacles.push({ lane:l2, y: road.topY - 110, r:16 });
      }

      // Occasionally block 2 lanes (forces lane choice)
      const pTwoBlocked = clamp(0 + (lvl-10)*0.02, 0, 0.30);
      if (lvl >= 12 && Math.random() < pTwoBlocked){
        const safe = lanes[Math.floor(Math.random()*3)];
        for (const ln of lanes){
          if (ln !== safe) obstacles.push({ lane:ln, y: road.topY - 170, r:16 });
        }
      }

      // Pickups:
      // - flowers are common
      // - second life is rare, only useful if lives < 2
      const flowerChance = 0.85;
      const lifeChanceBase = 0.14; // then throttled

      // flower chain
      if (Math.random() < flowerChance){
        const lane = Math.random() < 0.55 ? l2 : l1;
        const count = (lvl < 10) ? 2 : (lvl < 20 ? 3 : 4);
        for (let i=0;i<count;i++){
          pickups.push({ type:"flower", lane, y: road.topY - 140 - i*52, r:12, x:0 });
        }
      }

      // life pickup (Soufiane)
      // Rule: max 2 lives; if already 2, still spawn sometimes but it becomes points on pickup.
      // Additional rule: prevent "life farming": need a cooldown after a life gain.
      const timeSinceLifeGain = game.t - (game._lastLifeGainTime || -999);
      const lifeCooldownOk = timeSinceLifeGain > 6.0;

      if (Math.random() < lifeChanceBase && lvl >= 6 && lifeCooldownOk){
        const lane = lanes[Math.floor(Math.random()*3)];
        pickups.push({ type:"life", lane, y: road.topY - 210, r:12, x:0 });
      }
    }

    function updatePlayer(dt){
      // lane switching
      if (player.switching){
        player.switchT += dt;
        const a = Math.min(1, player.switchT / player.switchDuration);
        const fromX = laneX(player.fromLane, player.y);
        const toX = laneX(player.toLane, player.y);
        const eased = 1 - Math.pow(1-a, 3);
        player.x = fromX + (toX - fromX) * eased;
        if (a >= 1) player.switching = false;
      } else {
        player.x = laneX(player.lane, player.y);
      }

      // jump
      if (player.jumping){
        player.z += player.vz * dt;
        player.vz -= player.gravity * dt;
        if (player.z <= 0){
          player.z = 0;
          player.vz = 0;
          player.jumping = false;
        }
      }

      // invulnerability timer
      if (game.invuln > 0) game.invuln = Math.max(0, game.invuln - dt);
    }

    function updateWorld(dt){
      if (game.state !== "play") return;

      // score increases over time
      game.score += Math.floor(dt * 18 * game.mult);
      updateDifficulty();

      // scroll
      game.scroll += game.speed * dt;

      // spawn patterns
      game.spawnTimer += dt;
      if (game.spawnTimer >= game.spawnEvery){
        game.spawnTimer = 0;
        spawnPattern();
      }

      // obstacles movement & collision
      for (let i=obstacles.length-1;i>=0;i--){
        const o = obstacles[i];
        o.y += game.speed * dt;

        const canHit = (player.z < 74) && (game.invuln <= 0);
        const ox = laneX(o.lane, o.y);
        const py = player.y - player.z;

        if (canHit && circleHit(player.x, py, player.r*0.86, ox, o.y, (o.r || 18)*0.86)){
          onHit();
          // remove the obstacle that hit
          obstacles.splice(i,1);
          continue;
        }

        if (o.y > H + 150) obstacles.splice(i,1);
      }

      // pickups movement & collection
      for (let i=pickups.length-1;i>=0;i--){
        const p = pickups[i];
        p.y += game.speed * dt;

        const px = player.x;
        const py = player.y - player.z;
        const cx = laneX(p.lane, p.y);
        const pr = player.r*0.78;

        // allow pickup while jumping
        const collected = circleHit(px, py, pr, cx, p.y, (p.r || 14)*1.05);

        if (collected){
          if (p.type === "flower"){
            // points with combo
            game.combo += 1.0;
            game.lastFlowerTime = game.t;
            game.score += Math.floor(120 * game.mult);
          } else {
            // life pickup rules
            if (game.lives < 2){
              game.lives = 2;
              game.invuln = Math.max(game.invuln, 0.35); // small safety
              game._lastLifeGainTime = game.t;
            } else {
              // already 2 lives: convert to points, prevents infinite stacking
              game.score += 250;
              game._lastLifeGainTime = game.t; // still enforce cooldown so it doesn't spam
            }
          }
          pickups.splice(i,1);
          continue;
        }

        if (p.y > H + 150) pickups.splice(i,1);
      }

      // combo decay if no flowers
      if (game.t - game.lastFlowerTime > 1.4){
        game.combo = Math.max(0, game.combo - dt*1.3);
      }

      // camera shake decay
      if (game.shake > 0) game.shake = Math.max(0, game.shake - 40*dt);
    }

    function render(){
      // camera shake
      let sx = 0, sy = 0;
      if (game.shake > 0){
        sx = rand(-game.shake, game.shake);
        sy = rand(-game.shake, game.shake);
      }

      ctx.save();
      ctx.translate(sx, sy);
      ctx.clearRect(-50, -50, W+100, H+100);

      drawSkyGlow();

      // Crisp, stable environment
      drawSkyline(env.skylineA, game.scroll, "rgba(12, 26, 55, 0.85)", "rgba(255,255,255,0.06)");
      drawSkyline(env.skylineB, game.scroll, "rgba(18, 40, 80, 0.78)", "rgba(255,255,255,0.07)");
      drawFlags(game.scroll);

      drawRoad();

      // pickups then obstacles
      for (const p of pickups) drawPickup(p);
      for (const o of obstacles) drawObstacle(o);

      drawPlayer();
      drawOverlay();

      ctx.restore();
    }

    function loop(now){
      const dt = Math.min(0.033, (now - game.lastT)/1000);
      game.lastT = now;
      game.t += dt;

      if (game.state !== "pause"){
        updatePlayer(dt);
        updateWorld(dt);
      }
      render();

      // UI
      ui.score.textContent = String(game.score);
      ui.level.textContent = String(game.level);
      ui.mult.textContent = "x" + game.mult.toFixed(1);
      ui.lives.textContent = `${game.lives}/2`;

      requestAnimationFrame(loop);
    }

    // Init
    env.init();
    restart();
    loadAssets().then(() => requestAnimationFrame(loop));
  </script>
</body>
</html>
