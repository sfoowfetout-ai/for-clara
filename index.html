<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Clara Runner ✿</title>
  <style>
    :root{
      --ink:#1f2937;
      --paper:#f6f1e7;
      --paper2:#efe4d3;
      --tile:#d6b48c;
      --tile2:#c89a6e;
      --accent:#b51d3a;   /* rouge catalan */
      --sea:#0c6b7a;      /* bleu méditerranée */
      --shadow: 0 18px 50px rgba(0,0,0,.25);
      --stroke: rgba(31,41,55,.18);
    }

    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh;
      font-family: ui-serif, Georgia, "Times New Roman", Times, serif;
      color:var(--ink);
      display:flex; align-items:center; justify-content:center;
      padding:22px;

      /* paper + mediterranean light */
      background:
        radial-gradient(1100px 600px at 15% 10%, rgba(181,29,58,.14), transparent 58%),
        radial-gradient(900px 520px at 90% 20%, rgba(12,107,122,.18), transparent 56%),
        linear-gradient(180deg, var(--paper), var(--paper2));
    }

    .wrap{width:min(980px,100%); display:grid; gap:12px;}

    .card{
      background:
        linear-gradient(180deg, rgba(255,255,255,.55), rgba(255,255,255,.22)),
        radial-gradient(900px 400px at 20% 10%, rgba(181,29,58,.08), transparent 55%),
        radial-gradient(900px 400px at 90% 20%, rgba(12,107,122,.08), transparent 55%);
      border:1px solid var(--stroke);
      border-radius:18px;
      overflow:hidden;
      box-shadow: var(--shadow);
      position:relative;
    }

    /* subtle "tile" header stripe */
    .stripe{
      height:10px;
      background:
        repeating-linear-gradient(90deg,
          rgba(181,29,58,.85) 0 26px,
          rgba(12,107,122,.85) 26px 52px,
          rgba(200,154,110,.85) 52px 78px
        );
    }

    header{padding:18px 18px 10px;}
    .titleRow{display:flex; align-items:baseline; justify-content:space-between; gap:12px; flex-wrap:wrap;}
    h1{
      margin:0;
      font-size:22px;
      letter-spacing:-.02em;
    }
    .badge{
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(31,41,55,.18);
      background: rgba(255,255,255,.55);
    }
    p{
      margin:6px 0 0;
      color: rgba(31,41,55,.76);
      line-height:1.5;
      font-size:14.5px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }

    .row{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      padding:0 18px 14px;
      color: rgba(31,41,55,.72);
      font-size:13px;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    .pill{
      border:1px solid rgba(31,41,55,.18);
      background: rgba(255,255,255,.55);
      padding:6px 10px;
      border-radius:999px;
    }

    canvas{
      width:100%;
      height:auto;
      display:block;
      border-top:1px solid rgba(31,41,55,.14);
      background:
        radial-gradient(900px 420px at 50% 35%, rgba(12,107,122,.10), transparent 65%),
        linear-gradient(180deg, rgba(31,41,55,.05), rgba(31,41,55,.02));
    }

    .footer{
      display:flex; justify-content:space-between; flex-wrap:wrap; gap:10px;
      padding:12px 18px 16px;
      border-top:1px solid rgba(31,41,55,.14);
      align-items:center;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color: rgba(31,41,55,.72);
      font-size:12.5px;
    }
    .right{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}

    button{
      border:1px solid rgba(31,41,55,.20);
      background: rgba(255,255,255,.70);
      color: rgba(31,41,55,.90);
      padding:9px 12px;
      border-radius:999px;
      cursor:pointer;
      font-weight:700;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }
    button:hover{ background: rgba(255,255,255,.88); }

    .primary{
      border-color: rgba(181,29,58,.35);
      background: rgba(181,29,58,.10);
    }
    .primary:hover{ background: rgba(181,29,58,.16); }

    .hint{
      font-size:12px;
      opacity:.85;
      margin-left:10px;
    }
  </style>
</head>

<body>
  <main class="wrap">
    <section class="card">
      <div class="stripe"></div>
      <header>
        <div class="titleRow">
          <h1>Clara Runner ✿</h1>
          <span class="badge">vintage catalan • 3 lanes</span>
        </div>
        <p>Style Subway Surfers : ⬅️ ➡️ (ou A/D) pour changer de voie. Esquive les obstacles. Vitesse ↑.</p>
      </header>

      <div class="row">
        <span class="pill">⬅️ ➡️</span>
        <span class="pill">A / D</span>
        <span class="pill">Espace : pause</span>
        <span class="pill">R : restart</span>
      </div>

      <canvas id="game" width="900" height="540"></canvas>

      <div class="footer">
        <div>
          <span id="status">Chargement…</span>
          <span style="margin-left:10px">Score: <b id="score">0</b></span>
          <span style="margin-left:10px">Best: <b id="best">0</b></span>
          <span id="hint" class="hint"></span>
        </div>
        <div class="right">
          <button class="primary" id="btnRestart">Restart</button>
          <button id="btnMusic">Play music</button>
        </div>
      </div>
    </section>
  </main>

  <script>
    // ============= IMPORTANT =============
    // Fichiers à la racine du repo:
    // - clara.png
    // - ahmed.png   (si tu veux renommer en badvibes.png, change juste la ligne obstacle)
    // - music.mp3   (optionnel)
    //
    // Cache-buster: ?v=20260218 pour forcer GitHub Pages à recharger les nouvelles images.
    // =====================================
    const ASSET_VERSION = "20260218"; // change ce nombre si tu remplaces les images (ex: "20260218b")

    const ASSETS = {
      player: `clara.png?v=${ASSET_VERSION}`,
      obstacle: `ahmed.png?v=${ASSET_VERSION}`,  // ex: `badvibes.png?v=${ASSET_VERSION}`
      music: "music.mp3"
    };

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const ui = {
      status: document.getElementById("status"),
      score: document.getElementById("score"),
      best: document.getElementById("best"),
      hint: document.getElementById("hint"),
      btnRestart: document.getElementById("btnRestart"),
      btnMusic: document.getElementById("btnMusic"),
    };

    const BEST_KEY = "clara_runner_best_vintage";
    let best = Number(localStorage.getItem(BEST_KEY) || 0);
    ui.best.textContent = String(best);

    const W = canvas.width, H = canvas.height;

    // Perspective road
    const road = {
      topY: 72,
      botY: H - 35,
      topW: W * 0.18,
      botW: W * 0.76,
      cx: W / 2
    };

    const lanes = [-1, 0, 1];

    function roadWidthAt(y){
      const t = (y - road.topY) / (road.botY - road.topY);
      return road.topW + t * (road.botW - road.topW);
    }
    function roadXAt(y){
      const w = roadWidthAt(y);
      return { left: road.cx - w/2, w };
    }
    function laneX(lane, y){
      const { left, w } = roadXAt(y);
      const laneW = w / 3;
      const idx = lane === -1 ? 0 : (lane === 0 ? 1 : 2);
      return left + laneW*(idx + 0.5);
    }

    // Player (snap lane switch like Subway)
    const player = {
      lane: 0,
      y: H - 135,
      x: laneX(0, H - 135),
      r: 34,
      switchDuration: 0.09,
      switching: false,
      fromLane: 0,
      toLane: 0,
      switchT: 0
    };

    // Obstacles
    let obstacles = [];
    let spawnTimer = 0;
    let spawnEvery = 0.85;
    let speed = 260;
    let score = 0;

    // State
    let running = true;
    let gameOver = false;
    let lastT = performance.now();

    // Music
    const audio = new Audio();
    audio.loop = true;
    audio.preload = "auto";
    audio.src = ASSETS.music;
    let musicReady = false;
    audio.addEventListener("canplaythrough", () => { musicReady = true; });
    audio.addEventListener("error", () => { musicReady = false; });

    // Images
    const imgPlayer = new Image();
    const imgObstacle = new Image();
    let hasPlayer = false, hasObstacle = false;

    function tryLoad(img, src){
      return new Promise(res => {
        img.onload = () => res(true);
        img.onerror = () => res(false);
        img.src = src;
      });
    }

    async function loadAssets(){
      hasPlayer = await tryLoad(imgPlayer, ASSETS.player);
      hasObstacle = await tryLoad(imgObstacle, ASSETS.obstacle);

      const missing = [];
      if (!hasPlayer) missing.push("player");
      if (!hasObstacle) missing.push("obstacle");

      if (missing.length){
        ui.hint.textContent = `(${missing.join(", ")} image manquante — check noms/extension)`;
        ui.status.textContent = "OK (fallback)";
      } else {
        ui.hint.textContent = "";
        ui.status.textContent = "Go ✨";
      }
    }

    // Controls
    function requestLane(delta){
      if (gameOver) return;
      const idx = lanes.indexOf(player.lane);
      const next = lanes[Math.max(0, Math.min(2, idx + delta))];
      if (next === player.lane) return;

      player.switching = true;
      player.fromLane = player.lane;
      player.toLane = next;
      player.switchT = 0;
      player.lane = next;
    }

    window.addEventListener("keydown", (e) => {
      const k = (e.key || "").toLowerCase();
      if (k === "arrowleft" || k === "a") requestLane(-1);
      if (k === "arrowright" || k === "d") requestLane(+1);

      if (k === " "){
        e.preventDefault();
        running = !running;
        ui.status.textContent = running ? "Go ✨" : "Pause";
      }
      if (k === "r") restart();
    });

    ui.btnRestart.addEventListener("click", restart);
    ui.btnMusic.addEventListener("click", async () => {
      if (!musicReady){
        ui.status.textContent = "Ajoute music.mp3 (optionnel)";
        return;
      }
      if (audio.paused){
        try { await audio.play(); ui.btnMusic.textContent = "Stop music"; }
        catch { ui.status.textContent = "Audio bloqué (re-clique)"; }
      } else {
        audio.pause();
        ui.btnMusic.textContent = "Play music";
      }
    });

    function restart(){
      obstacles = [];
      spawnTimer = 0;
      spawnEvery = 0.85;
      speed = 260;
      score = 0;

      player.lane = 0;
      player.x = laneX(0, player.y);
      player.switching = false;

      running = true;
      gameOver = false;
      ui.status.textContent = "Go ✨";
    }

    function end(){
      gameOver = true;
      running = false;
      ui.status.textContent = "Game Over — R ou Restart";
      if (score > best){
        best = score;
        localStorage.setItem(BEST_KEY, String(best));
        ui.best.textContent = String(best);
      }
    }

    function spawn(){
      const lane = lanes[Math.floor(Math.random()*3)];
      obstacles.push({ lane, y: road.topY - 30, r: 18 });
    }

    function hit(px, py, pr, ox, oy, or){
      const dx = px - ox, dy = py - oy;
      return (dx*dx + dy*dy) <= (pr+or)*(pr+or);
    }

    // Draw road + 2 lane lines => 3 paths
    function drawRoad(t){
      // road polygon
      ctx.save();
      ctx.fillStyle = "rgba(31,41,55,.12)";
      ctx.beginPath();
      ctx.moveTo(road.cx - road.topW/2, road.topY);
      ctx.lineTo(road.cx + road.topW/2, road.topY);
      ctx.lineTo(road.cx + road.botW/2, road.botY);
      ctx.lineTo(road.cx - road.botW/2, road.botY);
      ctx.closePath();
      ctx.fill();

      // edges
      ctx.strokeStyle = "rgba(31,41,55,.22)";
      ctx.lineWidth = 3;
      ctx.stroke();

      // dashed lane separators (moving)
      ctx.strokeStyle = "rgba(255,255,255,.55)";
      ctx.lineWidth = 2;
      const dash = 18, gap = 16;
      const offset = (t * speed * 0.08) % (dash + gap);
      ctx.setLineDash([dash, gap]);
      ctx.lineDashOffset = -offset;

      const step = 16;
      for (let y = road.topY; y <= road.botY; y += step){
        const { left, w } = roadXAt(y);
        const laneW = w / 3;
        const x1 = left + laneW;
        const x2 = left + laneW * 2;

        const tt = (y - road.topY) / (road.botY - road.topY);
        const seg = 10 + tt * 18;

        ctx.beginPath(); ctx.moveTo(x1, y); ctx.lineTo(x1, y + seg); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x2, y); ctx.lineTo(x2, y + seg); ctx.stroke();
      }

      ctx.setLineDash([]);
      ctx.restore();
    }

    function drawCircleImage(img, x, y, r){
      const size = r * 2.35;
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.closePath();
      ctx.clip();
      ctx.drawImage(img, x - size/2, y - size/2, size, size);
      ctx.restore();

      ctx.save();
      ctx.strokeStyle = "rgba(31,41,55,.22)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    function drawPlayer(){
      const x = player.x, y = player.y;
      if (hasPlayer){
        drawCircleImage(imgPlayer, x, y, player.r);
      } else {
        ctx.save();
        ctx.fillStyle = "rgba(181,29,58,.12)";
        ctx.beginPath(); ctx.arc(x,y,player.r,0,Math.PI*2); ctx.fill();
        ctx.fillStyle = "rgba(31,41,55,.85)";
        ctx.font = "24px ui-sans-serif,system-ui";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText("✿", x, y+1);
        ctx.restore();
      }
    }

    function drawObstacle(o){
      const x = laneX(o.lane, o.y);
      const persp = (o.y - road.topY) / (road.botY - road.topY);
      const r = 14 + persp * 26;
      o.r = r;

      if (hasObstacle){
        drawCircleImage(imgObstacle, x, o.y, r);
      } else {
        ctx.save();
        ctx.fillStyle="rgba(12,107,122,.10)";
        ctx.beginPath(); ctx.arc(x,o.y,r,0,Math.PI*2); ctx.fill();
        ctx.fillStyle="rgba(31,41,55,.85)";
        ctx.font="22px ui-sans-serif,system-ui";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText("☁️", x, o.y+1);
        ctx.restore();
      }
    }

    function drawOverlay(){
      if (!gameOver) return;
      ctx.save();
      ctx.fillStyle = "rgba(246,241,231,.78)";
      ctx.fillRect(0, H/2 - 60, W, 120);
      ctx.strokeStyle = "rgba(31,41,55,.20)";
      ctx.lineWidth = 2;
      ctx.strokeRect(0, H/2 - 60, W, 120);

      ctx.fillStyle = "rgba(31,41,55,.92)";
      ctx.font = "bold 34px ui-sans-serif,system-ui";
      ctx.textAlign="center";
      ctx.fillText("Game Over", W/2, H/2 - 10);

      ctx.fillStyle = "rgba(31,41,55,.70)";
      ctx.font = "16px ui-sans-serif,system-ui";
      ctx.fillText("Appuie sur R ou clique Restart", W/2, H/2 + 22);
      ctx.restore();
    }

    function update(dt){
      // lane switch interpolation (snappy)
      if (player.switching){
        player.switchT += dt;
        const a = Math.min(1, player.switchT / player.switchDuration);
        const fromX = laneX(player.fromLane, player.y);
        const toX = laneX(player.toLane, player.y);
        const eased = 1 - Math.pow(1-a, 3);
        player.x = fromX + (toX - fromX) * eased;
        if (a >= 1) player.switching = false;
      } else {
        player.x = laneX(player.lane, player.y);
      }

      if (!running || gameOver) return;

      score += Math.floor(dt * 14);
      const lvl = Math.min(1.0, score / 1400);
      speed = 260 + lvl * 420;
      spawnEvery = 0.90 - lvl * 0.48;

      spawnTimer += dt;
      if (spawnTimer >= spawnEvery){
        spawnTimer = 0;
        spawn();
      }

      for (let i=obstacles.length-1;i>=0;i--){
        const o = obstacles[i];
        o.y += speed * dt;

        const ox = laneX(o.lane, o.y);
        if (hit(player.x, player.y, player.r*0.86, ox, o.y, o.r*0.86)){
          end(); return;
        }
        if (o.y > H + 80) obstacles.splice(i, 1);
      }
    }

    function render(t){
      ctx.clearRect(0,0,W,H);

      // soft vignette
      ctx.save();
      const g = ctx.createRadialGradient(W/2, H/2, 40, W/2, H/2, H*0.95);
      g.addColorStop(0, "rgba(255,255,255,.18)");
      g.addColorStop(1, "rgba(31,41,55,.10)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);
      ctx.restore();

      drawRoad(t);
      for (const o of obstacles) drawObstacle(o);
      drawPlayer();
      drawOverlay();

      ui.score.textContent = String(score);
    }

    function loop(now){
      const dt = Math.min(0.033, (now - lastT) / 1000);
      lastT = now;
      update(dt);
      render(now/1000);
      requestAnimationFrame(loop);
    }

    loadAssets().then(() => requestAnimationFrame(loop));
  </script>
</body>
</html>
