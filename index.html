<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Clara Dodge ✿</title>
  <style>
    :root{
      --bg1:#0b1220; --bg2:#111a2e;
      --txt: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.72);
      --stroke: rgba(255,255,255,.16);
      --card: rgba(255,255,255,.08);
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh; color:var(--txt);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:
        radial-gradient(1100px 600px at 12% 10%, rgba(255,105,180,.18), transparent 60%),
        radial-gradient(900px 500px at 90% 25%, rgba(0,200,255,.18), transparent 55%),
        linear-gradient(180deg,var(--bg1),var(--bg2));
      display:flex; align-items:center; justify-content:center; padding:22px;
    }
    .wrap{width:min(980px,100%); display:grid; gap:12px;}
    .card{
      background:var(--card); border:1px solid var(--stroke);
      border-radius:18px; overflow:hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,.45);
    }
    header{padding:18px 18px 10px;}
    h1{margin:0 0 6px; font-size:22px; letter-spacing:-.02em;}
    p{margin:0; color:var(--muted); line-height:1.5; font-size:14.5px;}
    .row{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      padding:0 18px 14px;
      color:var(--muted); font-size:13px;
    }
    .pill{
      border:1px solid var(--stroke); background: rgba(0,0,0,.18);
      padding:6px 10px; border-radius:999px;
    }
    canvas{
      width:100%; height:auto; display:block;
      border-top:1px solid rgba(255,255,255,.10);
    }
    .footer{
      display:flex; justify-content:space-between; flex-wrap:wrap; gap:10px;
      padding:12px 18px 16px; border-top:1px solid rgba(255,255,255,.10);
      color:var(--muted); font-size:12.5px;
    }
    button{
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.22);
      color:var(--txt);
      padding:9px 12px;
      border-radius:999px;
      cursor:pointer;
      font-weight:650;
    }
    button:hover{ background: rgba(255,255,255,.10); }
  </style>
</head>
<body>
  <main class="wrap">
    <section class="card">
      <header>
        <h1>Clara Dodge ✿</h1>
        <p>Gauche / Droite (ou A / D) pour bouger. Esquive les “bad vibes”. C’est cute, simple, et fun.</p>
      </header>

      <div class="row">
        <span class="pill">⬅️ ➡️ / A D</span>
        <span class="pill">Espace : pause</span>
        <span class="pill">R : restart</span>
        <span class="pill">Objectif : survivre + score</span>
      </div>

      <!-- Canvas 900x520 (scale auto via CSS) -->
      <canvas id="game" width="900" height="520" aria-label="Jeu"></canvas>

      <div class="footer">
        <div>
          <span id="status">Chargement…</span>
          <span style="margin-left:10px">Score: <b id="score">0</b></span>
          <span style="margin-left:10px">Best: <b id="best">0</b></span>
        </div>
        <div style="display:flex; gap:10px; flex-wrap:wrap">
          <button id="btnRestart">Restart</button>
          <button id="btnMute">Sound: OFF</button>
        </div>
      </div>
    </section>
  </main>

  <script>
    /**
     * OPTION IMAGES (facultatif)
     * - Mets ces fichiers dans le repo à la racine :
     *    clara.png       (sprite du joueur)
     *    obstacle.png    (nuage / bad vibes / emoji)
     * - Si pas trouvés, le jeu utilise des formes/emoji.
     */
    const ASSETS = {
      player: "clara.png",
      obstacle: "obstacle.png",
    };

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const ui = {
      status: document.getElementById("status"),
      score: document.getElementById("score"),
      best: document.getElementById("best"),
      btnRestart: document.getElementById("btnRestart"),
      btnMute: document.getElementById("btnMute"),
    };

    // Persistent best score
    const BEST_KEY = "clara_dodge_best";
    ui.best.textContent = String(Number(localStorage.getItem(BEST_KEY) || 0));

    // Game config
    const W = canvas.width, H = canvas.height;
    const laneY = H - 110;
    const player = { x: W/2, y: laneY, r: 34, speed: 520 };
    const obstacles = [];
    let keys = { left:false, right:false };
    let running = true;
    let gameOver = false;
    let tPrev = performance.now();
    let score = 0;
    let best = Number(localStorage.getItem(BEST_KEY) || 0);

    // Difficulty
    let spawnTimer = 0;
    let spawnInterval = 0.9; // seconds
    let obstacleSpeed = 220; // px/sec

    // Sound (very minimal, optional)
    let soundOn = false;
    const beep = (freq=440, ms=60) => {
      if (!soundOn) return;
      const ac = new (window.AudioContext || window.webkitAudioContext)();
      const o = ac.createOscillator();
      const g = ac.createGain();
      o.frequency.value = freq;
      o.type = "sine";
      o.connect(g); g.connect(ac.destination);
      g.gain.value = 0.05;
      o.start();
      setTimeout(()=>{ o.stop(); ac.close(); }, ms);
    };

    // Load images (optional)
    const imgPlayer = new Image();
    const imgObstacle = new Image();
    let hasPlayerImg = false, hasObstacleImg = false;

    function tryLoad(img, url){
      return new Promise((resolve) => {
        img.onload = () => resolve(true);
        img.onerror = () => resolve(false);
        img.src = url;
      });
    }

    async function loadAssets(){
      hasPlayerImg = await tryLoad(imgPlayer, ASSETS.player);
      hasObstacleImg = await tryLoad(imgObstacle, ASSETS.obstacle);
      ui.status.textContent = "Prête ✨ (gauche/droite pour jouer)";
    }

    // Input
    window.addEventListener("keydown", (e) => {
      const k = (e.key || "").toLowerCase();
      if (k === "arrowleft" || k === "a") keys.left = true;
      if (k === "arrowright" || k === "d") keys.right = true;
      if (k === " "){ running = !running; ui.status.textContent = running ? "Go ✨" : "Pause"; }
      if (k === "r") restart();
    });
    window.addEventListener("keyup", (e) => {
      const k = (e.key || "").toLowerCase();
      if (k === "arrowleft" || k === "a") keys.left = false;
      if (k === "arrowright" || k === "d") keys.right = false;
    });

    ui.btnRestart.addEventListener("click", restart);
    ui.btnMute.addEventListener("click", () => {
      soundOn = !soundOn;
      ui.btnMute.textContent = "Sound: " + (soundOn ? "ON" : "OFF");
      beep(660, 70);
    });

    // Utilities
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function rand(a,b){ return a + Math.random() * (b-a); }

    function circleHit(ax, ay, ar, bx, by, br){
      const dx = ax - bx, dy = ay - by;
      return (dx*dx + dy*dy) <= (ar+br)*(ar+br);
    }

    function spawnObstacle(){
      obstacles.push({
        x: rand(40, W-40),
        y: -30,
        r: rand(22, 34),
        vy: obstacleSpeed + rand(-30, 40),
        wobble: rand(0.6, 1.6),
        phase: rand(0, Math.PI*2),
      });
    }

    function restart(){
      obstacles.length = 0;
      score = 0;
      spawnTimer = 0;
      spawnInterval = 0.9;
      obstacleSpeed = 220;
      player.x = W/2;
      running = true;
      gameOver = false;
      ui.status.textContent = "Go ✨";
      beep(520, 80);
    }

    function endGame(){
      gameOver = true;
      running = false;
      ui.status.textContent = "Game Over — appuie sur R (ou Restart)";
      beep(220, 120);
      if (score > best){
        best = score;
        localStorage.setItem(BEST_KEY, String(best));
        ui.best.textContent = String(best);
      }
    }

    // Render
    function drawBackground(){
      // subtle stars
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,.06)";
      for (let i=0;i<35;i++){
        const x = (i*173) % W;
        const y = (i*97) % (H-80);
        ctx.beginPath();
        ctx.arc(x, y, (i%3)+0.6, 0, Math.PI*2);
        ctx.fill();
      }
      // ground line
      ctx.strokeStyle = "rgba(255,255,255,.10)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, laneY + 46);
      ctx.lineTo(W, laneY + 46);
      ctx.stroke();
      ctx.restore();
    }

    function drawPlayer(){
      if (hasPlayerImg){
        const size = player.r*2.2;
        ctx.drawImage(imgPlayer, player.x - size/2, player.y - size/2, size, size);
      } else {
        // cute circle + face
        ctx.save();
        ctx.fillStyle = "rgba(255,160,200,.28)";
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,.25)";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = "rgba(255,255,255,.9)";
        ctx.font = "24px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("✿", player.x, player.y+1);
        ctx.restore();
      }
    }

    function drawObstacle(o){
      if (hasObstacleImg){
        const size = o.r*2.2;
        ctx.drawImage(imgObstacle, o.x - size/2, o.y - size/2, size, size);
      } else {
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.22)";
        ctx.beginPath();
        ctx.arc(o.x, o.y, o.r, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,.18)";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = "rgba(255,255,255,.85)";
        ctx.font = "20px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("☁️", o.x, o.y+1); // "bad vibe" cloud
        ctx.restore();
      }
    }

    function drawHUD(){
      ui.score.textContent = String(score);
    }

    // Update loop
    function update(dt){
      if (!running || gameOver) return;

      // player movement
      let vx = 0;
      if (keys.left) vx -= player.speed;
      if (keys.right) vx += player.speed;
      player.x = clamp(player.x + vx*dt, 30, W-30);

      // difficulty scaling
      score += Math.floor(dt * 10); // +10 per second approx
      const level = Math.min(1.0, score / 900);
      spawnInterval = 0.95 - level * 0.45;   // from ~0.95s to ~0.50s
      obstacleSpeed  = 220 + level * 220;    // from 220 to 440

      // spawn
      spawnTimer += dt;
      if (spawnTimer >= spawnInterval){
        spawnTimer = 0;
        spawnObstacle();
      }

      // obstacles move & collision
      for (let i = obstacles.length - 1; i >= 0; i--){
        const o = obstacles[i];
        o.y += (o.vy + level*180) * dt;
        // wobble horizontally a bit
        o.x += Math.sin((performance.now()/1000)*o.wobble + o.phase) * 26 * dt;

        if (circleHit(player.x, player.y, player.r*0.85, o.x, o.y, o.r*0.85)){
          endGame();
          return;
        }
        if (o.y > H + 60){
          obstacles.splice(i, 1);
        }
      }
    }

    function render(){
      ctx.clearRect(0,0,W,H);

      // background gradient overlay
      ctx.save();
      const g = ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0, "rgba(255,255,255,.02)");
      g.addColorStop(1, "rgba(0,0,0,.08)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);
      ctx.restore();

      drawBackground();

      // obstacles
      for (const o of obstacles) drawObstacle(o);

      drawPlayer();

      // banner
      if (gameOver){
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.35)";
        ctx.fillRect(0, H/2 - 56, W, 112);
        ctx.fillStyle = "rgba(255,255,255,.92)";
        ctx.font = "bold 28px system-ui";
        ctx.textAlign = "center";
        ctx.fillText("Game Over", W/2, H/2 - 10);
        ctx.fillStyle = "rgba(255,255,255,.75)";
        ctx.font = "16px system-ui";
        ctx.fillText("Appuie sur R ou clique Restart", W/2, H/2 + 22);
        ctx.restore();
      }

      drawHUD();
    }

    function loop(tNow){
      const dt = Math.min(0.033, (tNow - tPrev) / 1000);
      tPrev = tNow;

      update(dt);
      render();

      requestAnimationFrame(loop);
    }

    // Start
    loadAssets().then(() => {
      ui.status.textContent = "Go ✨ (gauche/droite)";
      requestAnimationFrame(loop);
    });
  </script>
</body>
</html>
