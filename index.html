<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Clara Runner</title>
  <style>
    :root{
      /* Brighter, vivid palette */
      --sky1:#7dd3fc;
      --sky2:#a78bfa;
      --sky3:#fb7185;
      --sky4:#fbbf24;

      --night1:#0b1020;
      --night2:#0f1b3a;

      --txt:#0b1020;
      --txtInv:rgba(255,255,255,.95);
      --mutedInv:rgba(255,255,255,.78);

      --glass: rgba(255,255,255,.22);
      --glass2: rgba(255,255,255,.30);
      --stroke: rgba(255,255,255,.34);

      --accent:#ff2f5a;
      --sea:#16d3c8;
      --gold:#ffd166;

      --shadow: 0 24px 70px rgba(0,0,0,.40);
      --radius: 18px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}

    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:var(--txtInv);
      display:flex;
      align-items:center;
      justify-content:center;
      padding:22px;

      /* Brighter sky gradient */
      background:
        radial-gradient(1200px 800px at 12% 18%, rgba(125,211,252,.55), transparent 62%),
        radial-gradient(1100px 750px at 88% 20%, rgba(167,139,250,.50), transparent 60%),
        radial-gradient(1000px 700px at 55% 85%, rgba(251,113,133,.40), transparent 60%),
        radial-gradient(900px 600px at 40% 92%, rgba(251,191,36,.35), transparent 60%),
        linear-gradient(180deg, var(--night1), var(--night2));
    }

    .wrap{
      width:min(1120px, 100%);
      display:grid;
      gap:12px;
    }

    .card{
      border-radius: var(--radius);
      overflow:hidden;
      box-shadow: var(--shadow);
      position:relative;

      background:
        linear-gradient(180deg, rgba(255,255,255,.12), rgba(255,255,255,.06));
      border:1px solid rgba(255,255,255,.22);
      backdrop-filter: blur(10px);
    }

    .topbar{
      height:10px;
      background:
        repeating-linear-gradient(90deg,
          rgba(255,47,90,.92) 0 32px,
          rgba(255,209,102,.92) 32px 64px,
          rgba(22,211,200,.92) 64px 96px
        );
    }

    header{
      padding:18px 18px 10px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      flex-wrap:wrap;
    }

    .title h1{
      margin:0 0 6px;
      font-size: clamp(22px, 2.2vw, 32px);
      letter-spacing:-.02em;
      line-height:1.1;
    }

    .title p{
      margin:0;
      color: var(--mutedInv);
      font-size:14.5px;
      line-height:1.5;
      max-width: 820px;
    }

    .chips{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }

    .chip{
      border:1px solid rgba(255,255,255,.26);
      background: rgba(0,0,0,.16);
      padding:7px 10px;
      border-radius:999px;
      font-size:12.5px;
      color: rgba(255,255,255,.86);
      user-select:none;
      white-space:nowrap;
    }

    canvas{
      width:100%;
      height:auto;
      display:block;
      border-top:1px solid rgba(255,255,255,.14);
      border-bottom:1px solid rgba(255,255,255,.14);
      background:
        radial-gradient(1100px 520px at 50% 35%, rgba(255,255,255,.10), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,.10));
    }

    .footer{
      padding:12px 18px 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      color: rgba(255,255,255,.86);
      font-size:12.5px;
    }

    .hud{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }

    .stat{
      border:1px solid rgba(255,255,255,.22);
      background: rgba(0,0,0,.14);
      padding:8px 10px;
      border-radius:12px;
    }
    .stat b{color:rgba(255,255,255,.98)}

    .buttons{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }

    button{
      border:1px solid rgba(255,255,255,.28);
      background: rgba(0,0,0,.14);
      color: rgba(255,255,255,.96);
      padding:9px 12px;
      border-radius:999px;
      cursor:pointer;
      font-weight:800;
      letter-spacing:-.01em;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
    }
    button:hover{ background: rgba(255,255,255,.12); }
    button:active{ transform: scale(.98); }

    .primary{
      background: rgba(255,47,90,.20);
      border-color: rgba(255,47,90,.45);
    }
    .primary:hover{
      background: rgba(255,47,90,.30);
      border-color: rgba(255,47,90,.60);
    }

    .hint{
      opacity:.92;
      font-size:12px;
      color: rgba(255,255,255,.78);
      max-width: 520px;
    }
  </style>
</head>

<body>
  <main class="wrap">
    <section class="card">
      <div class="topbar"></div>

      <header>
        <div class="title">
          <h1>Clara Runner</h1>
          <p>
            Endless runner. Flèches gauche/droite pour changer de voie. Espace pour sauter et démarrer.
            P pour pause. R pour recommencer.
          </p>
        </div>
        <div class="chips">
          <span class="chip">Left/Right: lane</span>
          <span class="chip">Space: jump/start</span>
          <span class="chip">P: pause</span>
          <span class="chip">R: restart</span>
        </div>
      </header>

      <canvas id="game" width="1100" height="620"></canvas>

      <div class="footer">
        <div class="hud">
          <div class="stat">Status: <b id="status">Loading</b></div>
          <div class="stat">Score: <b id="score">0</b></div>
          <div class="stat">Best: <b id="best">0</b></div>
          <div class="stat">Level: <b id="level">1</b></div>
          <div class="stat">Multiplier: <b id="mult">x1.0</b></div>
          <span class="hint" id="hint"></span>
        </div>

        <div class="buttons">
          <button class="primary" id="btnRestart">Restart</button>
          <button id="btnMusic">Play music</button>
        </div>
      </div>
    </section>
  </main>

  <script>
    /*
      Place in repo root:
      - clara.png
      - obstacle image: badvibes.png OR ahmed.png OR obstacle.png
      - music.mp3 (optional)
      If assets look old, bump ASSET_VERSION.
    */
    const ASSET_VERSION = "v20";
    const ASSETS = {
      player: `clara.png?${ASSET_VERSION}`,
      obstacleCandidates: [
        `badvibes.png?${ASSET_VERSION}`,
        `ahmed.png?${ASSET_VERSION}`,
        `obstacle.png?${ASSET_VERSION}`
      ],
      music: `music.mp3?${ASSET_VERSION}`
    };

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const ui = {
      status: document.getElementById("status"),
      score: document.getElementById("score"),
      best: document.getElementById("best"),
      level: document.getElementById("level"),
      mult: document.getElementById("mult"),
      hint: document.getElementById("hint"),
      btnRestart: document.getElementById("btnRestart"),
      btnMusic: document.getElementById("btnMusic"),
    };

    const BEST_KEY = "clara_runner_best_bright";
    let best = Number(localStorage.getItem(BEST_KEY) || 0);
    ui.best.textContent = String(best);

    const W = canvas.width, H = canvas.height;

    // Audio (must be user-triggered)
    const audio = new Audio();
    audio.loop = true;
    audio.preload = "auto";
    audio.src = ASSETS.music;
    let musicReady = false;
    audio.addEventListener("canplaythrough", () => musicReady = true);
    audio.addEventListener("error", () => musicReady = false);

    // Images
    const imgPlayer = new Image();
    const imgObstacle = new Image();
    let hasPlayer = false, hasObstacle = false;
    let obstacleSrcUsed = "";

    function tryLoad(img, src){
      return new Promise(res => {
        img.onload = () => res(true);
        img.onerror = () => res(false);
        img.src = src;
      });
    }

    async function loadAssets(){
      hasPlayer = await tryLoad(imgPlayer, ASSETS.player);

      // Try multiple obstacle filenames automatically
      hasObstacle = false;
      for (const src of ASSETS.obstacleCandidates){
        const ok = await tryLoad(imgObstacle, src);
        if (ok){
          hasObstacle = true;
          obstacleSrcUsed = src;
          break;
        }
      }

      const problems = [];
      if (!hasPlayer) problems.push("clara.png not found");
      if (!hasObstacle) problems.push("obstacle image not found (badvibes.png / ahmed.png / obstacle.png)");

      if (problems.length){
        ui.hint.textContent = problems.join(" | ");
        ui.status.textContent = "Fallback";
      } else {
        ui.hint.textContent = `Obstacle loaded: ${obstacleSrcUsed.split("?")[0]}`;
        ui.status.textContent = "Press Space to Start";
      }
    }

    // Perspective road
    const road = {
      cx: W/2,
      topY: 95,
      botY: H - 50,
      topW: W * 0.15,
      botW: W * 0.80,
    };
    const lanes = [-1, 0, 1];
    const laneIndex = (lane) => lane === -1 ? 0 : (lane === 0 ? 1 : 2);

    function roadWAt(y){
      const t = (y - road.topY) / (road.botY - road.topY);
      return road.topW + t*(road.botW - road.topW);
    }
    function roadLeftAt(y){
      const w = roadWAt(y);
      return road.cx - w/2;
    }
    function laneX(lane, y){
      const left = roadLeftAt(y);
      const w = roadWAt(y);
      const lw = w/3;
      return left + lw*(laneIndex(lane) + 0.5);
    }

    // Game state
    const game = {
      state: "start", // start | play | pause | over
      lastT: performance.now(),
      t: 0,
      scroll: 0,
      speed: 300,
      spawnTimer: 0,
      spawnEvery: 0.90,
      score: 0,
      level: 1,
      mult: 1.0,
      combo: 0,
      lastCoinTime: 0,
      shake: 0,
    };

    // Player
    const player = {
      lane: 0,
      y: H - 165,
      x: laneX(0, H - 165),
      r: 36,

      // lane switch
      switching: false,
      fromLane: 0,
      toLane: 0,
      switchT: 0,
      switchDuration: 0.085,

      // jump
      jumping: false,
      z: 0,
      vz: 0,
      gravity: 3000,
      jumpPower: 1020,
    };

    // Entities
    let obstacles = [];
    let coins = [];
    let particles = [];

    // Controls
    function requestLane(delta){
      if (game.state !== "play") return;
      const idx = lanes.indexOf(player.lane);
      const next = lanes[Math.max(0, Math.min(2, idx + delta))];
      if (next === player.lane) return;

      player.switching = true;
      player.fromLane = player.lane;
      player.toLane = next;
      player.switchT = 0;
      player.lane = next;
    }

    function tryJump(){
      if (game.state !== "play") return;
      if (player.jumping) return;
      player.jumping = true;
      player.vz = player.jumpPower;
    }

    function togglePause(){
      if (game.state === "play"){
        game.state = "pause";
        ui.status.textContent = "Paused";
      } else if (game.state === "pause"){
        game.state = "play";
        ui.status.textContent = "Playing";
      }
    }

    function restart(){
      obstacles = [];
      coins = [];
      particles = [];

      game.state = "start";
      game.scroll = 0;
      game.speed = 300;
      game.spawnTimer = 0;
      game.spawnEvery = 0.90;
      game.score = 0;
      game.level = 1;
      game.mult = 1.0;
      game.combo = 0;
      game.lastCoinTime = 0;
      game.shake = 0;

      player.lane = 0;
      player.x = laneX(0, player.y);
      player.switching = false;
      player.jumping = false;
      player.z = 0;
      player.vz = 0;

      ui.status.textContent = "Press Space to Start";
      ui.score.textContent = "0";
      ui.level.textContent = "1";
      ui.mult.textContent = "x1.0";
    }

    function gameOver(){
      game.state = "over";
      ui.status.textContent = "Game Over";
      game.shake = 12;

      if (game.score > best){
        best = game.score;
        localStorage.setItem(BEST_KEY, String(best));
        ui.best.textContent = String(best);
      }
    }

    window.addEventListener("keydown", (e) => {
      const k = (e.key || "").toLowerCase();

      if (k === "arrowleft") requestLane(-1);
      if (k === "arrowright") requestLane(+1);

      if (k === " "){
        e.preventDefault();
        if (game.state === "start"){
          game.state = "play";
          ui.status.textContent = "Playing";
          return;
        }
        if (game.state === "play") tryJump();
      }

      if (k === "p"){
        if (game.state === "play" || game.state === "pause") togglePause();
      }

      if (k === "r") restart();
    });

    ui.btnRestart.addEventListener("click", restart);

    ui.btnMusic.addEventListener("click", async () => {
      if (!musicReady){
        ui.status.textContent = "No music.mp3 found";
        return;
      }
      if (audio.paused){
        try { await audio.play(); ui.btnMusic.textContent = "Stop music"; }
        catch { ui.status.textContent = "Click again to enable audio"; }
      } else {
        audio.pause();
        ui.btnMusic.textContent = "Play music";
      }
    });

    // Helpers
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function rand(a,b){ return a + Math.random()*(b-a); }
    function lerp(a,b,t){ return a + (b-a)*t; }

    function circleHit(ax, ay, ar, bx, by, br){
      const dx = ax-bx, dy = ay-by;
      return (dx*dx + dy*dy) <= (ar+br)*(ar+br);
    }

    // Decorative world
    const deco = {
      buildings: [],
      lamps: [],
      banners: [],
      init(){
        this.buildings.length = 0;
        this.lamps.length = 0;
        this.banners.length = 0;

        for (let i=0;i<28;i++){
          this.buildings.push({
            side: Math.random()<0.5 ? "L" : "R",
            baseY: rand(road.topY+20, road.botY-130),
            h: rand(110, 280),
            w: rand(60, 130),
            depth: rand(0.35, 1.0),
            tone: rand(0, 1),
            balcony: Math.random() < 0.65,
            flag: Math.random() < 0.65 ? (Math.random() < 0.65 ? "catalan" : "spain") : null,
          });
        }

        for (let i=0;i<22;i++){
          this.lamps.push({
            edge: Math.random()<0.5 ? -1 : 1,
            y: rand(road.topY+30, road.botY-90),
            depth: rand(0.45, 1.0),
          });
        }

        for (let i=0;i<12;i++){
          this.banners.push({
            y: rand(road.topY+60, road.botY-240),
            depth: rand(0.5, 1.0),
            type: Math.random()<0.6 ? "catalan" : "spain"
          });
        }
      }
    };

    function paletteStone(tone, a){
      // brighter, more saturated stones
      const P = [
        [255, 236, 200],  // light stone
        [255, 204, 160],  // peach
        [255, 176, 132],  // terracotta
        [170, 235, 240],  // sea tint
        [255, 226, 155],  // warm sand
      ];
      const idx = Math.floor(tone * P.length) % P.length;
      const [r,g,b] = P[idx];
      return `rgba(${r},${g},${b},${a})`;
    }

    function drawFlag(x, y, w, h, type, alpha){
      ctx.save();
      ctx.globalAlpha = alpha;

      // pole
      ctx.strokeStyle = "rgba(255,255,255,.55)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x, y+h);
      ctx.stroke();

      const xx = x + 2;
      const yy = y + 2;
      const ww = w;
      const hh = h;

      // wave clip
      ctx.save();
      ctx.beginPath();
      ctx.moveTo(xx, yy);
      ctx.quadraticCurveTo(xx+ww*0.55, yy+hh*0.15, xx+ww, yy+hh*0.05);
      ctx.quadraticCurveTo(xx+ww*0.55, yy+hh*0.55, xx+ww, yy+hh*0.40);
      ctx.quadraticCurveTo(xx+ww*0.55, yy+hh*0.92, xx+ww, yy+hh*0.75);
      ctx.lineTo(xx+ww, yy+hh);
      ctx.lineTo(xx, yy+hh);
      ctx.closePath();
      ctx.clip();

      if (type === "catalan"){
        const stripes = 6;
        for (let i=0;i<stripes;i++){
          ctx.fillStyle = (i%2===0) ? "rgba(255,209,102,.98)" : "rgba(255,47,90,.98)";
          ctx.fillRect(xx, yy + i*(hh/stripes), ww, (hh/stripes));
        }
      } else {
        ctx.fillStyle = "rgba(255,47,90,.98)";
        ctx.fillRect(xx, yy, ww, hh*0.28);
        ctx.fillStyle = "rgba(255,209,102,.98)";
        ctx.fillRect(xx, yy+hh*0.28, ww, hh*0.44);
        ctx.fillStyle = "rgba(255,47,90,.98)";
        ctx.fillRect(xx, yy+hh*0.72, ww, hh*0.28);
      }

      ctx.restore();
      ctx.restore();
    }

    function drawBuildings(scroll){
      const span = (road.botY - road.topY);
      for (const b of deco.buildings){
        let yy = b.baseY + (scroll * 0.22) * (1 - b.depth);
        while (yy > road.botY) yy -= span;

        const persp = (yy - road.topY) / (road.botY - road.topY);
        const scale = 0.55 + persp*0.90;

        const bw = b.w * scale;
        const bh = b.h * scale;

        const left = roadLeftAt(yy);
        const w = roadWAt(yy);

        const offset = 18 + (1 - b.depth) * 28;
        const x = b.side === "L" ? (left - offset - bw) : (left + w + offset);

        ctx.save();
        ctx.globalAlpha = 0.92 * (0.60 + b.depth*0.40);

        // building body
        ctx.fillStyle = paletteStone(b.tone, 0.95);
        ctx.fillRect(x, yy - bh, bw, bh);

        // bright edge highlight
        ctx.strokeStyle = "rgba(255,255,255,.26)";
        ctx.lineWidth = 2;
        ctx.strokeRect(x, yy - bh, bw, bh);

        // windows
        const pad = 10*scale;
        const ww = 11*scale, wh = 13*scale;
        const gapX = 8*scale, gapY = 10*scale;

        for (let r=0;r<7;r++){
          for (let c=0;c<4;c++){
            const px = x + pad + c*(ww+gapX);
            const py = (yy-bh) + pad + r*(wh+gapY);
            if (px+ww < x+bw-pad && py+wh < yy-8*scale){
              const lit = (Math.sin((px+py)*0.03) > 0.35);
              ctx.fillStyle = lit ? "rgba(255,209,102,.30)" : "rgba(10,16,32,.28)";
              ctx.fillRect(px, py, ww, wh);
            }
          }
        }

        // balconies
        if (b.balcony && persp > 0.25){
          const by = yy - bh + bh*0.58;
          ctx.fillStyle = "rgba(0,0,0,.14)";
          ctx.strokeStyle = "rgba(255,255,255,.22)";
          ctx.fillRect(x + bw*0.08, by, bw*0.84, 8*scale);
          ctx.strokeRect(x + bw*0.08, by, bw*0.84, 8*scale);

          ctx.globalAlpha *= 0.9;
          for (let i=0;i<10;i++){
            const rx = x + bw*0.10 + i*(bw*0.08);
            ctx.beginPath();
            ctx.moveTo(rx, by);
            ctx.lineTo(rx, by - 14*scale);
            ctx.stroke();
          }
          ctx.globalAlpha /= 0.9;
        }

        // flags
        if (b.flag && persp > 0.28){
          const fx = b.side === "L" ? (x + bw - 10*scale) : (x + 8*scale);
          const fy = yy - bh + 16*scale;
          drawFlag(fx, fy, 24*scale, 32*scale, b.flag, 0.98);
        }

        ctx.restore();
      }
    }

    function drawLamps(scroll){
      const span = (road.botY - road.topY);
      for (const l of deco.lamps){
        let yy = l.y + (scroll * 0.30) * (1 - l.depth);
        while (yy > road.botY) yy -= span;

        const persp = (yy - road.topY) / (road.botY - road.topY);
        const scale = 0.55 + persp*0.95;

        const left = roadLeftAt(yy);
        const w = roadWAt(yy);
        const edgeX = l.edge < 0 ? left : (left + w);
        const x = edgeX + (l.edge < 0 ? -18*scale : 18*scale);

        ctx.save();
        ctx.globalAlpha = 0.72;
        ctx.strokeStyle = "rgba(255,255,255,.26)";
        ctx.lineWidth = 2;

        // pole
        ctx.beginPath();
        ctx.moveTo(x, yy);
        ctx.lineTo(x, yy - 78*scale);
        ctx.stroke();

        // arm
        ctx.beginPath();
        ctx.moveTo(x, yy - 66*scale);
        ctx.lineTo(x + (l.edge < 0 ? 26*scale : -26*scale), yy - 58*scale);
        ctx.stroke();

        // bright glow
        const lx = x + (l.edge < 0 ? 30*scale : -30*scale);
        const ly = yy - 56*scale;
        const grd = ctx.createRadialGradient(lx, ly, 3, lx, ly, 30*scale);
        grd.addColorStop(0, "rgba(255,209,102,.28)");
        grd.addColorStop(1, "rgba(255,209,102,0)");
        ctx.fillStyle = grd;
        ctx.beginPath();
        ctx.arc(lx, ly, 30*scale, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
      }
    }

    function drawOverBanners(scroll){
      const span = (road.botY - road.topY);
      for (const b of deco.banners){
        let yy = b.y + (scroll * 0.26) * (1 - b.depth);
        while (yy > road.botY) yy -= span;

        const persp = (yy - road.topY) / (road.botY - road.topY);
        if (persp < 0.18 || persp > 0.62) continue;

        const left = roadLeftAt(yy);
        const w = roadWAt(yy);
        const x = left - w*0.08;
        const ww = w * 1.16;
        const hh = 18 + persp*18;

        ctx.save();
        ctx.globalAlpha = 0.70;

        // rope
        ctx.strokeStyle = "rgba(255,255,255,.24)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x, yy);
        ctx.lineTo(x+ww, yy);
        ctx.stroke();

        // banner cloth
        ctx.globalAlpha = 0.72;
        if (b.type === "catalan"){
          const stripes = 6;
          for (let i=0;i<stripes;i++){
            ctx.fillStyle = (i%2===0) ? "rgba(255,209,102,.55)" : "rgba(255,47,90,.55)";
            ctx.fillRect(x, yy + i*(hh/stripes), ww, (hh/stripes));
          }
        } else {
          ctx.fillStyle = "rgba(255,47,90,.55)";
          ctx.fillRect(x, yy, ww, hh*0.28);
          ctx.fillStyle = "rgba(255,209,102,.55)";
          ctx.fillRect(x, yy+hh*0.28, ww, hh*0.44);
          ctx.fillStyle = "rgba(255,47,90,.55)";
          ctx.fillRect(x, yy+hh*0.72, ww, hh*0.28);
        }

        ctx.restore();
      }
    }

    function drawRoad(t){
      // Road polygon
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.22)";
      ctx.beginPath();
      ctx.moveTo(road.cx - road.topW/2, road.topY);
      ctx.lineTo(road.cx + road.topW/2, road.topY);
      ctx.lineTo(road.cx + road.botW/2, road.botY);
      ctx.lineTo(road.cx - road.botW/2, road.botY);
      ctx.closePath();
      ctx.fill();

      // Edge highlight (brighter)
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.lineWidth = 3;
      ctx.stroke();

      // Lane separators (dashes)
      ctx.strokeStyle = "rgba(255,255,255,.22)";
      ctx.lineWidth = 2;

      const dash = 22, gap = 18;
      const offset = (t * game.speed * 0.11) % (dash+gap);
      ctx.setLineDash([dash, gap]);
      ctx.lineDashOffset = -offset;

      const step = 16;
      for (let y = road.topY; y <= road.botY; y += step){
        const left = roadLeftAt(y);
        const w = roadWAt(y);
        const lw = w/3;
        const x1 = left + lw;
        const x2 = left + lw*2;

        const persp = (y - road.topY) / (road.botY - road.topY);
        const seg = 10 + persp*26;

        ctx.beginPath(); ctx.moveTo(x1, y); ctx.lineTo(x1, y + seg); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x2, y); ctx.lineTo(x2, y + seg); ctx.stroke();
      }

      ctx.setLineDash([]);
      ctx.restore();
    }

    function spawnParticles(x, y, n, strength){
      for (let i=0;i<n;i++){
        particles.push({
          x, y,
          vx: rand(-1, 1) * strength,
          vy: rand(-1, 1) * strength,
          life: rand(0.28, 0.65),
          t: 0
        });
      }
    }

    function updateParticles(dt){
      for (let i=particles.length-1;i>=0;i--){
        const p = particles[i];
        p.t += dt;
        p.x += p.vx * 70 * dt;
        p.y += p.vy * 70 * dt;
        p.vy += 0.85 * dt;

        const a = 1 - (p.t / p.life);
        if (a <= 0){
          particles.splice(i,1);
          continue;
        }
        ctx.save();
        ctx.globalAlpha = a * 0.65;
        ctx.fillStyle = "rgba(255,209,102,.95)";
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2.4, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }
    }

    function drawCircleImage(img, x, y, r){
      const size = r * 2.35;
      ctx.save();
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.closePath();
      ctx.clip();
      ctx.drawImage(img, x - size/2, y - size/2, size, size);
      ctx.restore();

      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,.22)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.stroke();
      ctx.restore();
    }

    function drawPlayer(){
      const shadowScale = clamp(1 - (player.z / 210), 0.55, 1);

      // shadow
      ctx.save();
      ctx.globalAlpha = 0.28;
      ctx.fillStyle = "rgba(0,0,0,.55)";
      ctx.beginPath();
      ctx.ellipse(player.x, player.y + 28, 38*shadowScale, 13*shadowScale, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      const y = player.y - player.z;

      if (hasPlayer){
        drawCircleImage(imgPlayer, player.x, y, player.r);
      } else {
        ctx.save();
        ctx.fillStyle = "rgba(255,47,90,.20)";
        ctx.beginPath(); ctx.arc(player.x,y,player.r,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }

    function drawObstacle(o){
      const persp = (o.y - road.topY) / (road.botY - road.topY);
      const r = 14 + persp * 32;
      o.r = r;

      const x = laneX(o.lane, o.y);

      // subtle warning pulse at high level
      if (persp < 0.25 && game.level >= 7){
        ctx.save();
        ctx.globalAlpha = 0.16 + 0.08*Math.sin(game.t*10);
        ctx.fillStyle = "rgba(255,47,90,1)";
        ctx.beginPath();
        ctx.arc(x, o.y, 22, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();
      }

      if (hasObstacle){
        drawCircleImage(imgObstacle, x, o.y, r);
      } else {
        ctx.save();
        ctx.fillStyle = "rgba(22,211,200,.18)";
        ctx.beginPath(); ctx.arc(x,o.y,r,0,Math.PI*2); ctx.fill();
        ctx.restore();
      }
    }

    function drawCoin(c){
      const x = laneX(c.lane, c.y);
      const persp = (c.y - road.topY) / (road.botY - road.topY);
      const r = 8 + persp*14;

      ctx.save();
      ctx.globalAlpha = 0.92;
      ctx.fillStyle = "rgba(255,209,102,.92)";
      ctx.beginPath();
      ctx.arc(x, c.y, r, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = 0.30;
      ctx.strokeStyle = "rgba(255,255,255,.55)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, c.y, r, 0, Math.PI*2);
      ctx.stroke();

      ctx.restore();

      c.r = r;
      c.x = x;
    }

    function drawOverlay(){
      if (game.state === "start"){
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.18)";
        ctx.fillRect(0, 0, W, H);

        ctx.fillStyle = "rgba(255,255,255,.96)";
        ctx.font = "800 44px system-ui";
        ctx.textAlign = "center";
        ctx.fillText("Press Space to Start", W/2, H*0.44);

        ctx.fillStyle = "rgba(255,255,255,.80)";
        ctx.font = "16px system-ui";
        ctx.fillText("Left/Right to change lane. Space to jump. P to pause.", W/2, H*0.44 + 34);
        ctx.restore();
      }

      if (game.state === "pause"){
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.22)";
        ctx.fillRect(0, 0, W, H);
        ctx.fillStyle = "rgba(255,255,255,.96)";
        ctx.font = "800 46px system-ui";
        ctx.textAlign = "center";
        ctx.fillText("Paused", W/2, H*0.46);
        ctx.fillStyle = "rgba(255,255,255,.80)";
        ctx.font = "16px system-ui";
        ctx.fillText("Press P to resume", W/2, H*0.46 + 32);
        ctx.restore();
      }

      if (game.state === "over"){
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.28)";
        ctx.fillRect(0, H/2 - 84, W, 168);
        ctx.fillStyle = "rgba(255,255,255,.96)";
        ctx.font = "900 52px system-ui";
        ctx.textAlign="center";
        ctx.fillText("Game Over", W/2, H/2 - 14);
        ctx.fillStyle = "rgba(255,255,255,.82)";
        ctx.font = "16px system-ui";
        ctx.fillText("Press R to restart", W/2, H/2 + 28);
        ctx.restore();
      }
    }

    // Spawning and difficulty
    function spawnObstaclePattern(){
      const lvl = game.level;

      const l1 = lanes[Math.floor(Math.random()*3)];
      let l2 = l1;
      while (l2 === l1) l2 = lanes[Math.floor(Math.random()*3)];

      // always at least one
      obstacles.push({ lane: l1, y: road.topY - 60, r: 16 });

      // double obstacle chance increases
      const pDouble = clamp(0.06 + (lvl-3)*0.035, 0, 0.62);
      if (lvl >= 4 && Math.random() < pDouble){
        obstacles.push({ lane: l2, y: road.topY - 105, r: 16 });
      }

      // occasionally force a decision: two lanes blocked
      const pPair = clamp(0.00 + (lvl-8)*0.02, 0, 0.30);
      if (lvl >= 10 && Math.random() < pPair){
        const safe = lanes[Math.floor(Math.random()*3)];
        for (const ln of lanes){
          if (ln !== safe){
            obstacles.push({ lane: ln, y: road.topY - 160, r: 16 });
          }
        }
      }

      // coin line reward
      if (Math.random() < 0.82){
        const coinLane = Math.random() < 0.55 ? l2 : l1;
        const count = (lvl < 6) ? 2 : (lvl < 14 ? 3 : 4);
        for (let i=0;i<count;i++){
          coins.push({ lane: coinLane, y: road.topY - 130 - i*50, r: 10, x: 0 });
        }
      }
    }

    function updateDifficulty(){
      const lvl = 1 + Math.floor(game.score / 260);
      game.level = clamp(lvl, 1, 45);

      const k = clamp((game.level - 1) / 24, 0, 1);
      game.speed = 300 + k * 600;           // 300 -> 900
      game.spawnEvery = 0.92 - k * 0.50;    // 0.92 -> 0.42

      // multiplier reacts to combo
      const targetMult = 1 + clamp(game.combo / 18, 0, 2.8);
      game.mult = lerp(game.mult, targetMult, 0.06);
    }

    function updatePlayer(dt){
      // lane switching
      if (player.switching){
        player.switchT += dt;
        const a = Math.min(1, player.switchT / player.switchDuration);
        const fromX = laneX(player.fromLane, player.y);
        const toX = laneX(player.toLane, player.y);
        const eased = 1 - Math.pow(1-a, 3);
        player.x = fromX + (toX - fromX) * eased;
        if (a >= 1) player.switching = false;
      } else {
        player.x = laneX(player.lane, player.y);
      }

      // jump
      if (player.jumping){
        player.z += player.vz * dt;
        player.vz -= player.gravity * dt;
        if (player.z <= 0){
          player.z = 0;
          player.vz = 0;
          player.jumping = false;
        }
      }
    }

    function updateWorld(dt){
      if (game.state !== "play") return;

      // score
      game.score += Math.floor(dt * 18 * game.mult);
      updateDifficulty();

      // scroll
      game.scroll += game.speed * dt;

      // spawn
      game.spawnTimer += dt;
      if (game.spawnTimer >= game.spawnEvery){
        game.spawnTimer = 0;
        spawnObstaclePattern();
      }

      // obstacle movement and collision
      for (let i=obstacles.length-1;i>=0;i--){
        const o = obstacles[i];
        o.y += game.speed * dt;

        const canHit = (player.z < 72);
        const ox = laneX(o.lane, o.y);
        const py = player.y - player.z;

        if (canHit && circleHit(player.x, py, player.r*0.86, ox, o.y, o.r*0.86)){
          spawnParticles(player.x, py, 26, 2.4);
          gameOver();
          return;
        }

        if (o.y > H + 140) obstacles.splice(i,1);
      }

      // coins
      for (let i=coins.length-1;i>=0;i--){
        const c = coins[i];
        c.y += game.speed * dt;

        const cx = laneX(c.lane, c.y);
        const py = player.y - player.z;
        const r = 8 + ((c.y - road.topY)/(road.botY-road.topY))*14;

        if (circleHit(player.x, py, player.r*0.75, cx, c.y, r)){
          coins.splice(i,1);
          game.combo += 1.0;
          game.lastCoinTime = game.t;
          game.score += 45;
          spawnParticles(cx, c.y, 14, 1.8);
          continue;
        }

        if (c.y > H + 140) coins.splice(i,1);
      }

      // combo decay if no coins
      if (game.t - game.lastCoinTime > 1.2){
        game.combo = Math.max(0, game.combo - dt*1.2);
      }
    }

    function render(dt){
      // camera shake
      let sx = 0, sy = 0;
      if (game.shake > 0){
        sx = rand(-game.shake, game.shake);
        sy = rand(-game.shake, game.shake);
        game.shake = Math.max(0, game.shake - 40*dt);
      }

      ctx.save();
      ctx.translate(sx, sy);

      ctx.clearRect(-50, -50, W+100, H+100);

      // bright atmosphere
      ctx.save();
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0.00, "rgba(125,211,252,.18)");
      g.addColorStop(0.35, "rgba(167,139,250,.14)");
      g.addColorStop(0.70, "rgba(251,113,133,.10)");
      g.addColorStop(1.00, "rgba(0,0,0,.06)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);
      ctx.restore();

      // decor
      drawBuildings(game.scroll);
      drawLamps(game.scroll);
      drawOverBanners(game.scroll);

      // road
      drawRoad(game.t);

      // coins
      for (const c of coins) drawCoin(c);

      // obstacles
      for (const o of obstacles) drawObstacle(o);

      // particles
      updateParticles(dt);

      // player
      drawPlayer();

      // overlay
      drawOverlay();

      ctx.restore();
    }

    function loop(now){
      const dt = Math.min(0.033, (now - game.lastT)/1000);
      game.lastT = now;
      game.t += dt;

      if (game.state !== "pause"){
        updatePlayer(dt);
        updateWorld(dt);
      }

      render(dt);

      ui.score.textContent = String(game.score);
      ui.level.textContent = String(game.level);
      ui.mult.textContent = "x" + game.mult.toFixed(1);

      requestAnimationFrame(loop);
    }

    // Init
    deco.init();
    restart();
    loadAssets().then(() => requestAnimationFrame(loop));
  </script>
</body>
</html>
