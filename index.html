<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Clara Road ✿</title>
  <style>
    :root{
      --bg1:#071021; --bg2:#0b1a33;
      --txt: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.70);
      --stroke: rgba(255,255,255,.14);
      --card: rgba(255,255,255,.08);
    }
    *{box-sizing:border-box}
    body{
      margin:0; min-height:100vh; color:var(--txt);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:
        radial-gradient(1100px 600px at 12% 10%, rgba(255,105,180,.18), transparent 60%),
        radial-gradient(900px 500px at 88% 20%, rgba(0,200,255,.16), transparent 55%),
        linear-gradient(180deg,var(--bg1),var(--bg2));
      display:flex; align-items:center; justify-content:center; padding:22px;
    }
    .wrap{width:min(980px,100%); display:grid; gap:12px;}
    .card{
      background:var(--card);
      border:1px solid var(--stroke);
      border-radius:18px;
      overflow:hidden;
      box-shadow: 0 20px 60px rgba(0,0,0,.45);
    }
    header{padding:18px 18px 10px;}
    h1{margin:0 0 6px; font-size:22px; letter-spacing:-.02em;}
    p{margin:0; color:var(--muted); line-height:1.5; font-size:14.5px;}
    .row{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center;
      padding:0 18px 14px;
      color:var(--muted); font-size:13px;
    }
    .pill{
      border:1px solid var(--stroke); background: rgba(0,0,0,.18);
      padding:6px 10px; border-radius:999px;
    }
    canvas{
      width:100%; height:auto; display:block;
      border-top:1px solid rgba(255,255,255,.10);
    }
    .footer{
      display:flex; justify-content:space-between; flex-wrap:wrap; gap:10px;
      padding:12px 18px 16px; border-top:1px solid rgba(255,255,255,.10);
      color:var(--muted); font-size:12.5px;
    }
    button{
      border:1px solid var(--stroke);
      background: rgba(0,0,0,.22);
      color:var(--txt);
      padding:9px 12px;
      border-radius:999px;
      cursor:pointer;
      font-weight:650;
    }
    button:hover{ background: rgba(255,255,255,.10); }
  </style>
</head>

<body>
  <main class="wrap">
    <section class="card">
      <header>
        <h1>Clara Road ✿</h1>
        <p>Choisis une voie : gauche / milieu / droite. Esquive les “bad vibes”. Ça accélère petit à petit.</p>
      </header>

      <div class="row">
        <span class="pill">⬅️ ➡️ : changer de voie</span>
        <span class="pill">A / D : changer de voie</span>
        <span class="pill">Espace : pause</span>
        <span class="pill">R : restart</span>
        <span class="pill">M : musique ON/OFF</span>
      </div>

      <canvas id="game" width="900" height="520"></canvas>

      <div class="footer">
        <div>
          <span id="status">Chargement…</span>
          <span style="margin-left:10px">Score: <b id="score">0</b></span>
          <span style="margin-left:10px">Best: <b id="best">0</b></span>
          <span style="margin-left:10px">Vitesse: <b id="spd">1.0x</b></span>
        </div>
        <div style="display:flex; gap:10px; flex-wrap:wrap">
          <button id="btnRestart">Restart</button>
          <button id="btnMusic">Music: OFF</button>
        </div>
      </div>
    </section>
  </main>

  <script>
    // =======================
    // ASSETS (mets ces fichiers à la racine du repo)
    // =======================
    // - clara.jpeg
    // - badvibe.jpeg   (renomme ton "Ahmed.jpeg" en badvibe.jpeg)
    // - music.mp3      (optionnel) => sinon on génère une musique simple
    const ASSETS = {
      player: "clara.jpeg",
      enemy: "badvibe.jpeg",
      music: "music.mp3"
    };

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const ui = {
      status: document.getElementById("status"),
      score: document.getElementById("score"),
      best: document.getElementById("best"),
      spd: document.getElementById("spd"),
      btnRestart: document.getElementById("btnRestart"),
      btnMusic: document.getElementById("btnMusic"),
    };

    // Best score persist
    const BEST_KEY = "clara_road_best";
    let best = Number(localStorage.getItem(BEST_KEY) || 0);
    ui.best.textContent = String(best);

    const W = canvas.width, H = canvas.height;

    // 3 lanes
    const laneX = [W * 0.30, W * 0.50, W * 0.70];
    const roadLeft = W * 0.20;
    const roadRight = W * 0.80;

    const player = {
      lane: 1, // 0 left, 1 mid, 2 right
      x: laneX[1],
      y: H - 95,
      r: 28
    };

    const enemies = [];
    let running = true;
    let gameOver = false;
    let score = 0;
    let speed = 1.0;        // increases over time
    let baseEnemySpeed = 210;
    let spawnTimer = 0;
    let spawnEvery = 0.85;  // seconds (will decrease a bit)
    let tPrev = performance.now();

    // Images
    const imgP = new Image();
    const imgE = new Image();
    let hasP = false, hasE = false;

    function tryLoad(img, url){
      return new Promise((resolve) => {
        img.onload = () => resolve(true);
        img.onerror = () => resolve(false);
        img.src = url;
      });
    }

    // Music: try file music.mp3, else simple generated synth
    let musicOn = false;
    let audioEl = null;

    function setupAudio(){
      // Try to load file
      audioEl = new Audio();
      audioEl.loop = true;
      audioEl.src = ASSETS.music;
      audioEl.addEventListener("error", () => {
        // If file missing, we keep audioEl but won't rely on it
      });
    }

    async function toggleMusic(force){
      const next = (typeof force === "boolean") ? force : !musicOn;
      musicOn = next;
      ui.btnMusic.textContent = "Music: " + (musicOn ? "ON" : "OFF");

      if (!audioEl) setupAudio();

      if (musicOn){
        try { await audioEl.play(); } catch(e) {
          // Autoplay may be blocked until user interaction; it's fine.
        }
      } else {
        try { audioEl.pause(); } catch(e) {}
      }
    }

    // Input lane switch
    function setLane(l){
      player.lane = Math.max(0, Math.min(2, l));
      player.x = laneX[player.lane];
    }

    window.addEventListener("keydown", (e) => {
      const k = (e.key || "").toLowerCase();
      if (k === "arrowleft" || k === "a") setLane(player.lane - 1);
      if (k === "arrowright" || k === "d") setLane(player.lane + 1);

      if (k === " "){
        e.preventDefault();
        running = !running;
        ui.status.textContent = running ? "Go ✨" : "Pause";
      }
      if (k === "r") restart();
      if (k === "m") toggleMusic();
    });

    ui.btnRestart.addEventListener("click", restart);
    ui.btnMusic.addEventListener("click", () => toggleMusic());

    function restart(){
      enemies.length = 0;
      score = 0;
      speed = 1.0;
      spawnTimer = 0;
      spawnEvery = 0.85;
      baseEnemySpeed = 210;
      running = true;
      gameOver = false;
      setLane(1);
      ui.status.textContent = "Go ✨";
    }

    function endGame(){
      gameOver = true;
      running = false;
      ui.status.textContent = "Game Over — R ou Restart";
      if (score > best){
        best = score;
        localStorage.setItem(BEST_KEY, String(best));
        ui.best.textContent = String(best);
      }
    }

    function rand(a,b){ return a + Math.random() * (b-a); }

    function spawnEnemy(){
      // avoid spawning exactly on player lane too often
      const lane = (Math.random() < 0.55) ? Math.floor(rand(0,3)) : ((player.lane + (Math.random()<0.5?1:2)) % 3);
      enemies.push({
        lane,
        x: laneX[lane],
        y: -70,
        r: 26,
        vy: (baseEnemySpeed + rand(-15, 40)) * speed
      });
    }

    function hit(ax, ay, ar, bx, by, br){
      const dx = ax - bx, dy = ay - by;
      return (dx*dx + dy*dy) <= (ar+br)*(ar+br);
    }

    // Sakura petals
    const petals = Array.from({length: 26}, () => ({
      x: rand(roadLeft, roadRight),
      y: rand(-H, 0),
      r: rand(2.0, 4.2),
      vy: rand(18, 42),
      vx: rand(-12, 12),
      phase: rand(0, Math.PI*2),
      wobble: rand(1.2, 2.6),
    }));

    function updatePetals(dt){
      for (const p of petals){
        p.y += (p.vy * (0.8 + speed*0.08)) * dt;
        p.x += (p.vx + Math.sin(performance.now()/1000 * p.wobble + p.phase) * 10) * dt;
        if (p.y > H + 10){
          p.y = rand(-80, -10);
          p.x = rand(roadLeft, roadRight);
        }
        if (p.x < roadLeft - 20) p.x = roadRight + 20;
        if (p.x > roadRight + 20) p.x = roadLeft - 20;
      }
    }

    function drawPetals(){
      ctx.save();
      ctx.fillStyle = "rgba(255,180,210,.35)";
      for (const p of petals){
        ctx.beginPath();
        ctx.ellipse(p.x, p.y, p.r*1.2, p.r, Math.sin(p.phase)*0.8, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.restore();
    }

    function drawRoad(){
      // Road body
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.22)";
      ctx.fillRect(roadLeft, 0, roadRight - roadLeft, H);

      // Lane separators
      ctx.strokeStyle = "rgba(255,255,255,.12)";
      ctx.lineWidth = 2;
      ctx.setLineDash([18, 14]);
      for (let i=1;i<=2;i++){
        const x = (roadLeft + (roadRight-roadLeft)*(i/3));
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, H);
        ctx.stroke();
      }
      ctx.setLineDash([]);

      // Side borders
      ctx.strokeStyle = "rgba(255,255,255,.18)";
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.moveTo(roadLeft, 0); ctx.lineTo(roadLeft, H); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(roadRight, 0); ctx.lineTo(roadRight, H); ctx.stroke();
      ctx.restore();
    }

    function drawPlayer(){
      const size = player.r*2.3;
      if (hasP){
        ctx.save();
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
        ctx.closePath();
        ctx.clip();
        ctx.drawImage(imgP, player.x - size/2, player.y - size/2, size, size);
        ctx.restore();

        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,.25)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.save();
        ctx.fillStyle = "rgba(255,160,200,.28)";
        ctx.beginPath();
        ctx.arc(player.x, player.y, player.r, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,.25)";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = "rgba(255,255,255,.9)";
        ctx.font = "22px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("✿", player.x, player.y+1);
        ctx.restore();
      }
    }

    function drawEnemy(e){
      const size = e.r*2.3;
      if (hasE){
        ctx.save();
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
        ctx.closePath();
        ctx.clip();
        ctx.drawImage(imgE, e.x - size/2, e.y - size/2, size, size);
        ctx.restore();

        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,.16)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
        ctx.stroke();
        ctx.restore();
      } else {
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.28)";
        ctx.beginPath();
        ctx.arc(e.x, e.y, e.r, 0, Math.PI*2);
        ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,.14)";
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.fillStyle = "rgba(255,255,255,.85)";
        ctx.font = "20px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("☁️", e.x, e.y+1);
        ctx.restore();
      }
    }

    function render(){
      ctx.clearRect(0,0,W,H);

      // subtle overlay
      const g = ctx.createLinearGradient(0,0,0,H);
      g.addColorStop(0, "rgba(255,255,255,.02)");
      g.addColorStop(1, "rgba(0,0,0,.12)");
      ctx.fillStyle = g;
      ctx.fillRect(0,0,W,H);

      drawRoad();
      drawPetals();

      for (const e of enemies) drawEnemy(e);
      drawPlayer();

      if (gameOver){
        ctx.save();
        ctx.fillStyle = "rgba(0,0,0,.40)";
        ctx.fillRect(0, H/2 - 58, W, 116);
        ctx.fillStyle = "rgba(255,255,255,.92)";
        ctx.font = "bold 30px system-ui";
        ctx.textAlign = "center";
        ctx.fillText("Game Over", W/2, H/2 - 10);
        ctx.fillStyle = "rgba(255,255,255,.75)";
        ctx.font = "16px system-ui";
        ctx.fillText("Appuie sur R ou clique Restart", W/2, H/2 + 22);
        ctx.restore();
      }

      ui.score.textContent = String(score);
      ui.spd.textContent = speed.toFixed(1) + "x";
    }

    function update(dt){
      updatePetals(dt);

      if (!running || gameOver) return;

      // Score & speed ramp
      score += Math.floor(dt * 12); // ~12 points/s
      speed = 1.0 + Math.min(2.5, score / 700); // 1.0x -> up to 3.5x

      // Spawn gets faster
      spawnEvery = Math.max(0.38, 0.85 - (speed-1)*0.18);

      spawnTimer += dt;
      if (spawnTimer >= spawnEvery){
        spawnTimer = 0;
        spawnEnemy();
      }

      // Enemies movement and collision
      for (let i=enemies.length-1; i>=0; i--){
        const e = enemies[i];
        e.y += (baseEnemySpeed * speed) * dt;

        if (hit(player.x, player.y, player.r*0.9, e.x, e.y, e.r*0.9)){
          endGame();
          return;
        }
        if (e.y > H + 80){
          enemies.splice(i,1);
        }
      }
    }

    function loop(tNow){
      const dt = Math.min(0.033, (tNow - tPrev)/1000);
      tPrev = tNow;
      update(dt);
      render();
      requestAnimationFrame(loop);
    }

    async function init(){
      setupAudio();

      hasP = await tryLoad(imgP, ASSETS.player);
      hasE = await tryLoad(imgE, ASSETS.enemy);

      ui.status.textContent = "Go ✨ (3 voies)";
      requestAnimationFrame(loop);
    }

    init();
  </script>
</body>
</html>
